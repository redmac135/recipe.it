declare type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    readonly [Symbol.toStringTag]: string;
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    private readonly _cancelHandlers;
    private readonly _promise;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

declare type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
declare type Headers = Record<string, string>;
declare type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
    ENCODE_PATH?: (path: string) => string;
};

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

declare type StartWorkflow = {
    name?: string;
    version?: number;
    correlationId?: string;
    input?: Record<string, any>;
    taskToDomain?: Record<string, string>;
};

declare type TaskDetails = {
    workflowId?: string;
    taskRefName?: string;
    output?: Record<string, any>;
    taskId?: string;
};

declare type Action = {
    action?: 'start_workflow' | 'complete_task' | 'fail_task';
    start_workflow?: StartWorkflow;
    complete_task?: TaskDetails;
    fail_task?: TaskDetails;
    expandInlineJSON?: boolean;
};

declare type EventHandler = {
    name: string;
    event: string;
    condition?: string;
    actions: Array<Action>;
    active?: boolean;
    evaluatorType?: string;
};

declare class EventResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get queue config by name
     * @param queueType
     * @param queueName
     * @returns any OK
     * @throws ApiError
     */
    getQueueConfig(queueType: string, queueName: string): CancelablePromise<any>;
    /**
     * Create or update queue config by name
     * @param queueType
     * @param queueName
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    putQueueConfig(queueType: string, queueName: string, requestBody: string): CancelablePromise<any>;
    /**
     * Delete queue config by name
     * @param queueType
     * @param queueName
     * @returns any OK
     * @throws ApiError
     */
    deleteQueueConfig(queueType: string, queueName: string): CancelablePromise<any>;
    /**
     * Get all the event handlers
     * @returns EventHandler OK
     * @throws ApiError
     */
    getEventHandlers(): CancelablePromise<Array<EventHandler>>;
    /**
     * Update an existing event handler.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    updateEventHandler(requestBody: EventHandler): CancelablePromise<any>;
    /**
     * Add a new event handler.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    addEventHandler(requestBody: EventHandler): CancelablePromise<any>;
    /**
     * Get all queue configs
     * @returns any OK
     * @throws ApiError
     */
    getQueueNames(): CancelablePromise<any>;
    /**
     * Remove an event handler
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    removeEventHandlerStatus(name: string): CancelablePromise<any>;
    /**
     * Get event handlers for a given event
     * @param event
     * @param activeOnly
     * @returns EventHandler OK
     * @throws ApiError
     */
    getEventHandlersForEvent(event: string, activeOnly?: boolean): CancelablePromise<Array<EventHandler>>;
}

declare class HealthCheckResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * @returns any OK
     * @throws ApiError
     */
    doCheck(): CancelablePromise<Record<string, any>>;
}

declare type TaskDef = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    name: string;
    description?: string;
    retryCount?: number;
    timeoutSeconds: number;
    inputKeys?: Array<string>;
    outputKeys?: Array<string>;
    timeoutPolicy?: 'RETRY' | 'TIME_OUT_WF' | 'ALERT_ONLY';
    retryLogic?: 'FIXED' | 'EXPONENTIAL_BACKOFF' | 'LINEAR_BACKOFF';
    retryDelaySeconds?: number;
    responseTimeoutSeconds?: number;
    concurrentExecLimit?: number;
    inputTemplate?: Record<string, any>;
    rateLimitPerFrequency?: number;
    rateLimitFrequencyInSeconds?: number;
    isolationGroupId?: string;
    executionNameSpace?: string;
    ownerEmail?: string;
    pollTimeoutSeconds?: number;
    backoffScaleFactor?: number;
};

declare type SubWorkflowParams = {
    name: string;
    version?: number;
    taskToDomain?: Record<string, string>;
    workflowDefinition?: WorkflowDef$1;
    idempotencyKey?: string;
    idempotencyStrategy?: 'FAIL' | 'RETURN_EXISTING';
};

declare type WorkflowTask = {
    name: string;
    taskReferenceName: string;
    description?: string;
    inputParameters?: Record<string, any>;
    type?: string;
    dynamicTaskNameParam?: string;
    /**
     * @deprecated
     */
    caseValueParam?: string;
    /**
     * @deprecated
     */
    caseExpression?: string;
    scriptExpression?: string;
    decisionCases?: Record<string, Array<WorkflowTask>>;
    /**
     * @deprecated
     */
    dynamicForkJoinTasksParam?: string;
    dynamicForkTasksParam?: string;
    dynamicForkTasksInputParamName?: string;
    defaultCase?: Array<WorkflowTask>;
    forkTasks?: Array<Array<WorkflowTask>>;
    startDelay?: number;
    subWorkflowParam?: SubWorkflowParams;
    joinOn?: Array<string>;
    sink?: string;
    optional?: boolean;
    taskDefinition?: TaskDef;
    rateLimited?: boolean;
    defaultExclusiveJoinTask?: Array<string>;
    asyncComplete?: boolean;
    loopCondition?: string;
    loopOver?: Array<WorkflowTask>;
    retryCount?: number;
    evaluatorType?: string;
    expression?: string;
    workflowTaskType?: 'SIMPLE' | 'DYNAMIC' | 'FORK_JOIN' | 'FORK_JOIN_DYNAMIC' | 'DECISION' | 'SWITCH' | 'JOIN' | 'DO_WHILE' | 'SUB_WORKFLOW' | 'START_WORKFLOW' | 'EVENT' | 'WAIT' | 'HUMAN' | 'USER_DEFINED' | 'HTTP' | 'LAMBDA' | 'INLINE' | 'EXCLUSIVE_JOIN' | 'TERMINATE' | 'KAFKA_PUBLISH' | 'JSON_JQ_TRANSFORM' | 'SET_VARIABLE';
};

declare type WorkflowDef$1 = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    name: string;
    description?: string;
    version?: number;
    tasks: Array<WorkflowTask>;
    inputParameters?: Array<string>;
    outputParameters?: Record<string, any>;
    failureWorkflow?: string;
    schemaVersion?: number;
    restartable?: boolean;
    workflowStatusListenerEnabled?: boolean;
    ownerEmail?: string;
    timeoutPolicy?: 'TIME_OUT_WF' | 'ALERT_ONLY';
    timeoutSeconds: number;
    variables?: Record<string, any>;
    inputTemplate?: Record<string, any>;
};

declare class MetadataResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Gets the task definition
     * @param tasktype
     * @param metadata
     * @returns TaskDef OK
     * @throws ApiError
     */
    getTaskDef(tasktype: string, metadata?: boolean): CancelablePromise<TaskDef>;
    /**
     * Remove a task definition
     * @param tasktype
     * @returns any OK
     * @throws ApiError
     */
    unregisterTaskDef(tasktype: string): CancelablePromise<any>;
    /**
     * Retrieves all workflow definition along with blueprint
     * @param access
     * @param metadata
     * @param tagKey
     * @param tagValue
     * @returns WorkflowDef OK
     * @throws ApiError
     */
    getAllWorkflows(access?: string, metadata?: boolean, tagKey?: string, tagValue?: string): CancelablePromise<Array<WorkflowDef$1>>;
    /**
     * Create or update workflow definition(s)
     * @param requestBody
     * @param overwrite
     * @returns any OK
     * @throws ApiError
     */
    update(requestBody: Array<WorkflowDef$1>, overwrite?: boolean): CancelablePromise<any>;
    /**
     * Create a new workflow definition
     * @param requestBody
     * @param overwrite
     * @returns any OK
     * @throws ApiError
     */
    create(requestBody: WorkflowDef$1, overwrite?: boolean): CancelablePromise<any>;
    /**
     * Gets all task definition
     * @param access
     * @param metadata
     * @param tagKey
     * @param tagValue
     * @returns TaskDef OK
     * @throws ApiError
     */
    getTaskDefs(access?: string, metadata?: boolean, tagKey?: string, tagValue?: string): CancelablePromise<Array<TaskDef>>;
    /**
     * Update an existing task
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    updateTaskDef(requestBody: TaskDef): CancelablePromise<any>;
    /**
     * Create or update task definition(s)
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    registerTaskDef(requestBody: Array<TaskDef>): CancelablePromise<any>;
    /**
     * Removes workflow definition. It does not remove workflows associated with the definition.
     * @param name
     * @param version
     * @returns any OK
     * @throws ApiError
     */
    unregisterWorkflowDef(name: string, version: number): CancelablePromise<any>;
    /**
     * Retrieves workflow definition along with blueprint
     * @param name
     * @param version
     * @param metadata
     * @returns WorkflowDef OK
     * @throws ApiError
     */
    get(name: string, version?: number, metadata?: boolean): CancelablePromise<WorkflowDef$1>;
}

declare type StartWorkflowRequest = {
    name: string;
    version?: number;
    correlationId?: string;
    input?: Record<string, any>;
    taskToDomain?: Record<string, string>;
    workflowDef?: WorkflowDef$1;
    externalInputPayloadStoragePath?: string;
    idempotencyKey?: string;
    idempotencyStrategy?: 'FAIL' | 'RETURN_EXISTING';
    priority?: number;
    createdBy?: string;
};

declare type SaveScheduleRequest = {
    name: string;
    cronExpression: string;
    runCatchupScheduleInstances?: boolean;
    paused?: boolean;
    startWorkflowRequest?: StartWorkflowRequest;
    createdBy?: string;
    updatedBy?: string;
    scheduleStartTime?: number;
    scheduleEndTime?: number;
};

declare type WorkflowScheduleExecutionModel = {
    executionId?: string;
    scheduleName?: string;
    scheduledTime?: number;
    executionTime?: number;
    workflowName?: string;
    workflowId?: string;
    reason?: string;
    stackTrace?: string;
    startWorkflowRequest?: StartWorkflowRequest;
    state?: 'POLLED' | 'FAILED' | 'EXECUTED';
};

declare type SearchResultWorkflowScheduleExecutionModel = {
    totalHits?: number;
    results?: Array<WorkflowScheduleExecutionModel>;
};

declare type WorkflowSchedule = {
    name?: string;
    cronExpression?: string;
    runCatchupScheduleInstances?: boolean;
    paused?: boolean;
    startWorkflowRequest?: StartWorkflowRequest;
    scheduleStartTime?: number;
    scheduleEndTime?: number;
    createTime?: number;
    updatedTime?: number;
    createdBy?: string;
    updatedBy?: string;
};

declare class SchedulerResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get an existing workflow schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    getSchedule(name: string): CancelablePromise<any>;
    /**
     * Deletes an existing workflow schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    deleteSchedule(name: string): CancelablePromise<any>;
    /**
     * Get list of the next x (default 3, max 5) execution times for a scheduler
     * @param cronExpression
     * @param scheduleStartTime
     * @param scheduleEndTime
     * @param limit
     * @returns number OK
     * @throws ApiError
     */
    getNextFewSchedules(cronExpression: string, scheduleStartTime?: number, scheduleEndTime?: number, limit?: number): CancelablePromise<Array<number>>;
    /**
     * Pauses an existing schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    pauseSchedule(name: string): CancelablePromise<any>;
    /**
     * Pause all scheduling in a single conductor server instance (for debugging only)
     * @returns any OK
     * @throws ApiError
     */
    pauseAllSchedules(): CancelablePromise<Record<string, any>>;
    /**
     * Resume a paused schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    resumeSchedule(name: string): CancelablePromise<any>;
    /**
     * Requeue all execution records
     * @returns any OK
     * @throws ApiError
     */
    requeueAllExecutionRecords(): CancelablePromise<Record<string, any>>;
    /**
     * Resume all scheduling
     * @returns any OK
     * @throws ApiError
     */
    resumeAllSchedules(): CancelablePromise<Record<string, any>>;
    /**
     * Get all existing workflow schedules and optionally filter by workflow name
     * @param workflowName
     * @returns WorkflowSchedule OK
     * @throws ApiError
     */
    getAllSchedules(workflowName?: string): CancelablePromise<Array<WorkflowSchedule>>;
    /**
     * Create or update a schedule for a specified workflow with a corresponding start workflow request
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    saveSchedule(requestBody: SaveScheduleRequest): CancelablePromise<any>;
    /**
     * Test timeout - do not use in production
     * @returns any OK
     * @throws ApiError
     */
    testTimeout(): CancelablePromise<any>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowScheduleExecutionModel OK
     * @throws ApiError
     */
    searchV21(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflowScheduleExecutionModel>;
}

declare type ExternalStorageLocation = {
    uri?: string;
    path?: string;
};

declare type PollData = {
    queueName?: string;
    domain?: string;
    workerId?: string;
    lastPollTime?: number;
};

declare type Task = {
    taskType?: string;
    status?: 'IN_PROGRESS' | 'CANCELED' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS' | 'SCHEDULED' | 'TIMED_OUT' | 'SKIPPED';
    inputData?: Record<string, any>;
    referenceTaskName?: string;
    retryCount?: number;
    seq?: number;
    correlationId?: string;
    pollCount?: number;
    taskDefName?: string;
    scheduledTime?: number;
    startTime?: number;
    endTime?: number;
    updateTime?: number;
    startDelayInSeconds?: number;
    retriedTaskId?: string;
    retried?: boolean;
    executed?: boolean;
    callbackFromWorker?: boolean;
    responseTimeoutSeconds?: number;
    workflowInstanceId?: string;
    workflowType?: string;
    taskId?: string;
    reasonForIncompletion?: string;
    callbackAfterSeconds?: number;
    workerId?: string;
    outputData?: Record<string, any>;
    workflowTask?: WorkflowTask;
    domain?: string;
    rateLimitPerFrequency?: number;
    rateLimitFrequencyInSeconds?: number;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    workflowPriority?: number;
    executionNameSpace?: string;
    isolationGroupId?: string;
    iteration?: number;
    subWorkflowId?: string;
    subworkflowChanged?: boolean;
    queueWaitTime?: number;
    taskDefinition?: TaskDef;
    loopOverTask?: boolean;
};

declare type SearchResultTask = {
    totalHits?: number;
    results?: Array<Task>;
};

declare type TaskSummary = {
    workflowId?: string;
    workflowType?: string;
    correlationId?: string;
    scheduledTime?: string;
    startTime?: string;
    updateTime?: string;
    endTime?: string;
    status?: 'IN_PROGRESS' | 'CANCELED' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS' | 'SCHEDULED' | 'TIMED_OUT' | 'SKIPPED';
    reasonForIncompletion?: string;
    executionTime?: number;
    queueWaitTime?: number;
    taskDefName?: string;
    taskType?: string;
    input?: string;
    output?: string;
    taskId?: string;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    workflowPriority?: number;
};

declare type SearchResultTaskSummary = {
    totalHits?: number;
    results?: Array<TaskSummary>;
};

declare type TaskExecLog = {
    log?: string;
    taskId?: string;
    createdTime?: number;
};

declare type TaskResult = {
    workflowInstanceId: string;
    taskId: string;
    reasonForIncompletion?: string;
    callbackAfterSeconds?: number;
    workerId?: string;
    status?: 'IN_PROGRESS' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED';
    outputData?: Record<string, any>;
    logs?: Array<TaskExecLog>;
    externalOutputPayloadStoragePath?: string;
    subWorkflowId?: string;
};

declare class TaskResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Poll for a task of a certain type
     * @param tasktype
     * @param workerid
     * @param domain
     * @returns Task OK
     * @throws ApiError
     */
    poll(tasktype: string, workerid?: string, domain?: string): CancelablePromise<Task>;
    /**
     * Get the details about each queue
     * @returns number OK
     * @throws ApiError
     */
    allVerbose(): CancelablePromise<Record<string, Record<string, Record<string, number>>>>;
    /**
     * Update a task By Ref Name
     * @param workflowId
     * @param taskRefName
     * @param status
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    updateTask(workflowId: string, taskRefName: string, status: 'IN_PROGRESS' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED', requestBody: Record<string, any>): CancelablePromise<string>;
    /**
     * Get task by Id
     * @param taskId
     * @returns Task OK
     * @throws ApiError
     */
    getTask(taskId: string): CancelablePromise<Task>;
    /**
     * Get the details about each queue
     * @returns number OK
     * @throws ApiError
     */
    all(): CancelablePromise<Record<string, number>>;
    /**
     * Requeue pending tasks
     * @param taskType
     * @returns string OK
     * @throws ApiError
     */
    requeuePendingTask(taskType: string): CancelablePromise<string>;
    /**
     * Search for tasks based in payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultTaskSummary OK
     * @throws ApiError
     */
    search(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultTaskSummary>;
    /**
     * Search for tasks based in payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultTask OK
     * @throws ApiError
     */
    searchV22(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultTask>;
    /**
     * Get the last poll data for a given task type
     * @param taskType
     * @returns PollData OK
     * @throws ApiError
     */
    getPollData(taskType: string): CancelablePromise<Array<PollData>>;
    /**
     * Get Task Execution Logs
     * @param taskId
     * @returns TaskExecLog OK
     * @throws ApiError
     */
    getTaskLogs(taskId: string): CancelablePromise<Array<TaskExecLog>>;
    /**
     * Log Task Execution Details
     * @param taskId
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    log(taskId: string, requestBody: string): CancelablePromise<any>;
    /**
     * Get the last poll data for all task types
     * @returns PollData OK
     * @throws ApiError
     */
    getAllPollData(): CancelablePromise<Array<PollData>>;
    /**
     * Batch poll for a task of a certain type
     * @param tasktype
     * @param workerid
     * @param domain
     * @param count
     * @param timeout
     * @returns Task OK
     * @throws ApiError
     */
    batchPoll(tasktype: string, workerid?: string, domain?: string, count?: number, timeout?: number): CancelablePromise<Array<Task>>;
    /**
     * Update a task
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    updateTask1(requestBody: TaskResult): CancelablePromise<string>;
    /**
     * Get Task type queue sizes
     * @param taskType
     * @returns number OK
     * @throws ApiError
     */
    size1(taskType?: Array<string>): CancelablePromise<Record<string, number>>;
    /**
     * Get the external uri where the task payload is to be stored
     * @param path
     * @param operation
     * @param payloadType
     * @returns ExternalStorageLocation OK
     * @throws ApiError
     */
    getExternalStorageLocation1(path: string, operation: string, payloadType: string): CancelablePromise<ExternalStorageLocation>;
}

declare type GenerateTokenRequest = {
    keyId: string;
    keySecret: string;
    refreshTokenInterval?: number;
};

declare type Response$1 = {};

declare class TokenResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Generate JWT with the given access key
     * @param requestBody
     * @returns Response OK
     * @throws ApiError
     */
    generateToken(requestBody: GenerateTokenRequest): CancelablePromise<Response$1>;
    /**
     * Get the user info from the token
     * @returns any OK
     * @throws ApiError
     */
    getUserInfo(): CancelablePromise<any>;
}

declare type BulkResponse = {
    bulkErrorResults?: Record<string, string>;
    bulkSuccessfulResults?: Array<string>;
};

declare class WorkflowBulkResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Retry the last failed task for each workflow from the list
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    retry(requestBody: Array<string>): CancelablePromise<BulkResponse>;
    /**
     * Restart the list of completed workflow
     * @param requestBody
     * @param useLatestDefinitions
     * @returns BulkResponse OK
     * @throws ApiError
     */
    restart(requestBody: Array<string>, useLatestDefinitions?: boolean): CancelablePromise<BulkResponse>;
    /**
     * Terminate workflows execution
     * @param requestBody
     * @param reason
     * @returns BulkResponse OK
     * @throws ApiError
     */
    terminate(requestBody: Array<string>, reason?: string): CancelablePromise<BulkResponse>;
    /**
     * Resume the list of workflows
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    resumeWorkflow(requestBody: Array<string>): CancelablePromise<BulkResponse>;
    /**
     * Pause the list of workflows
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    pauseWorkflow1(requestBody: Array<string>): CancelablePromise<BulkResponse>;
}

declare type RerunWorkflowRequest = {
    reRunFromWorkflowId?: string;
    workflowInput?: Record<string, any>;
    reRunFromTaskId?: string;
    taskInput?: Record<string, any>;
    correlationId?: string;
};

declare type WorkflowSummary = {
    workflowType?: string;
    version?: number;
    workflowId?: string;
    correlationId?: string;
    startTime?: string;
    updateTime?: string;
    endTime?: string;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
    input?: string;
    output?: string;
    reasonForIncompletion?: string;
    executionTime?: number;
    event?: string;
    failedReferenceTaskNames?: string;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    priority?: number;
    createdBy?: string;
    outputSize?: number;
    inputSize?: number;
};

declare type ScrollableSearchResultWorkflowSummary = {
    results?: Array<WorkflowSummary>;
    totalHits?: number;
};

declare type Workflow = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
    idempotencyKey?: string;
    endTime?: number;
    workflowId?: string;
    parentWorkflowId?: string;
    parentWorkflowTaskId?: string;
    tasks?: Array<Task>;
    input?: Record<string, any>;
    output?: Record<string, any>;
    correlationId?: string;
    reRunFromWorkflowId?: string;
    reasonForIncompletion?: string;
    event?: string;
    taskToDomain?: Record<string, string>;
    failedReferenceTaskNames?: Array<string>;
    workflowDefinition?: WorkflowDef$1;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    priority?: number;
    variables?: Record<string, any>;
    lastRetriedTime?: number;
    startTime?: number;
    workflowVersion?: number;
    workflowName?: string;
};

declare type SearchResultWorkflow = {
    totalHits?: number;
    results?: Array<Workflow>;
};

declare type SearchResultWorkflowSummary = {
    totalHits?: number;
    results?: Array<WorkflowSummary>;
};

declare type SkipTaskRequest = {
    taskInput?: Record<string, any>;
    taskOutput?: Record<string, any>;
};

declare type WorkflowRun = {
    correlationId?: string;
    createTime?: number;
    createdBy?: string;
    priority?: number;
    requestId?: string;
    status?: string;
    tasks?: Array<Task>;
    updateTime?: number;
    workflowId?: string;
    variables?: Record<string, object>;
    input?: Record<string, object>;
    output?: Record<string, object>;
};

declare type WorkflowStatus = {
    workflowId?: string;
    correlationId?: string;
    output?: Record<string, any>;
    variables?: Record<string, any>;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
};

declare type TaskMock = {
    executionTime?: number;
    output: Record<string, any>;
    queueWaitTime?: number;
    status: "IN_PROGRESS" | "FAILED" | "FAILED_WITH_TERMINAL_ERROR" | "COMPLETED";
};

declare type WorkflowTestRequest = {
    correlationId?: string;
    createdBy?: string;
    externalInputPayloadStoragePath?: string;
    idempotencyKey?: string;
    idempotencyStrategy?: "FAIL" | "RETURN_EXISTING";
    input?: Record<string, Record<string, any>>;
    name: string;
    priority?: number;
    subWorkflowTestRequest?: Record<string, WorkflowTestRequest>;
    taskRefToMockOutput?: Record<string, Array<TaskMock>>;
    taskToDomain?: Record<string, string>;
    version?: number;
    workflowDef?: WorkflowDef$1;
};

declare class WorkflowResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Retrieve all the running workflows
     * @param name
     * @param version
     * @param startTime
     * @param endTime
     * @returns string OK
     * @throws ApiError
     */
    getRunningWorkflow(name: string, version?: number, startTime?: number, endTime?: number): CancelablePromise<Array<string>>;
    /**
     * Execute a workflow synchronously
     * @param body
     * @param name
     * @param version
     * @param requestId
     * @param waitUntilTaskRef
     * @param callback
     * @returns workflowRun
     * @throws ApiError
     */
    executeWorkflow(body: StartWorkflowRequest, name: string, version: number, requestId: string, waitUntilTaskRef: string): CancelablePromise<WorkflowRun>;
    /**
     * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    startWorkflow(requestBody: StartWorkflowRequest): CancelablePromise<string>;
    /**
     * Starts the decision task for a workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    decide(workflowId: string): CancelablePromise<any>;
    /**
     * Reruns the workflow from a specific task
     * @param workflowId
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    rerun(workflowId: string, requestBody: RerunWorkflowRequest): CancelablePromise<string>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflow OK
     * @throws ApiError
     */
    searchV21(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflow>;
    /**
     * Pauses the workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    pauseWorkflow(workflowId: string): CancelablePromise<any>;
    /**
     * Skips a given task from a current running workflow
     * @param workflowId
     * @param taskReferenceName
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    skipTaskFromWorkflow(workflowId: string, taskReferenceName: string, requestBody?: SkipTaskRequest): CancelablePromise<any>;
    /**
     * Lists workflows for the given correlation id list
     * @param name
     * @param requestBody
     * @param includeClosed
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getWorkflows(name: string, requestBody: Array<string>, includeClosed?: boolean, includeTasks?: boolean): CancelablePromise<Record<string, Array<Workflow>>>;
    /**
     * Gets the workflow by workflow id
     * @param workflowId
     * @param includeOutput
     * @param includeVariables
     * @returns WorkflowStatus OK
     * @throws ApiError
     */
    getWorkflowStatusSummary(workflowId: string, includeOutput?: boolean, includeVariables?: boolean): CancelablePromise<WorkflowStatus>;
    /**
     * Lists workflows for the given correlation id
     * @param name
     * @param correlationId
     * @param includeClosed
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getWorkflows1(name: string, correlationId: string, includeClosed?: boolean, includeTasks?: boolean): CancelablePromise<Array<Workflow>>;
    /**
     * Retries the last failed task
     * @param workflowId
     * @param resumeSubworkflowTasks
     * @returns void
     * @throws ApiError
     */
    retry1(workflowId: string, resumeSubworkflowTasks?: boolean): CancelablePromise<void>;
    /**
     * Gets the workflow by workflow id
     * @param workflowId
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getExecutionStatus(workflowId: string, includeTasks?: boolean): CancelablePromise<Workflow>;
    /**
     * Terminate workflow execution
     * @param workflowId
     * @param reason
     * @returns any OK
     * @throws ApiError
     */
    terminate1(workflowId: string, reason?: string): CancelablePromise<any>;
    /**
     * Resumes the workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    resumeWorkflow(workflowId: string): CancelablePromise<any>;
    /**
     * Removes the workflow from the system
     * @param workflowId
     * @param archiveWorkflow
     * @returns any OK
     * @throws ApiError
     */
    delete(workflowId: string, archiveWorkflow?: boolean): CancelablePromise<any>;
    /**
     * Search for workflows based on task parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowSummary OK
     * @throws ApiError
     */
    searchWorkflowsByTasks(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflowSummary>;
    /**
     * Get the uri and path of the external storage where the workflow payload is to be stored
     * @param path
     * @param operation
     * @param payloadType
     * @returns ExternalStorageLocation OK
     * @throws ApiError
     */
    getExternalStorageLocation(path: string, operation: string, payloadType: string): CancelablePromise<ExternalStorageLocation>;
    /**
     * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking
     * @param name
     * @param requestBody
     * @param version
     * @param correlationId
     * @param priority
     * @returns string OK
     * @throws ApiError
     */
    startWorkflow1(name: string, requestBody: Record<string, any>, version?: number, correlationId?: string, priority?: number): CancelablePromise<string>;
    /**
     * Restarts a completed workflow
     * @param workflowId
     * @param useLatestDefinitions
     * @returns void
     * @throws ApiError
     */
    restart1(workflowId: string, useLatestDefinitions?: boolean): CancelablePromise<void>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param queryId
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @param skipCache
     * @returns ScrollableSearchResultWorkflowSummary OK
     * @throws ApiError
     */
    search1(queryId?: string, start?: number, size?: number, sort?: string, freeText?: string, query?: string, skipCache?: boolean): CancelablePromise<ScrollableSearchResultWorkflowSummary>;
    /**
     * Search for workflows based on task parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflow OK
     * @throws ApiError
     */
    searchWorkflowsByTasksV2(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflow>;
    /**
     * Resets callback times of all non-terminal SIMPLE tasks to 0
     * @param workflowId
     * @returns void
     * @throws ApiError
     */
    resetWorkflow(workflowId: string): CancelablePromise<void>;
    /**
     * Test workflow execution using mock data
     * @param requestBody
     * @returns Workflow OK
     * @throws ApiError
     */
    testWorkflow(requestBody: WorkflowTestRequest): CancelablePromise<Workflow>;
}

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
declare const request$1: <T>(config: OpenAPIConfig, options: ApiRequestOptions) => CancelablePromise<T>;

/**
 * A handler to modify requests made by ConductorClient. Useful for metrics/option transformation/etc.
 *
 * @remarks
 * Example: Customizing the request URL
 * ```
 *
 * const requestCustomizer = (request, config, options) =>  {
 *  const url = options.url.replace(/^\/api/, '')
 *  return request(config, {...options, url });
 * }
 * const config = { BASE: "https://my-api.com"}
 * const client = new ConductorClient(config, requestCustomizer)
 * ```
 *
 * @param request the underlying node-fetch powered function
 * @param config @see OpenAPIConfig
 * @param options {see ApiRequestOptions}
 */
declare type RequestType = typeof request$1;
declare type ConductorHttpRequest = <T>(request: RequestType, config: OpenAPIConfig, options: ApiRequestOptions) => CancelablePromise<T>;

declare type HumanTaskUser = {
    user?: string;
    userType?: 'EXTERNAL_USER' | 'EXTERNAL_GROUP' | 'CONDUCTOR_USER' | 'CONDUCTOR_GROUP';
};

declare type HumanTaskAssignment = {
    assignee?: HumanTaskUser;
    slaMinutes?: number;
};

declare type HumanTaskTrigger = {
    startWorkflowRequest?: StartWorkflowRequest;
    triggerType?: 'ASSIGNEE_CHANGED' | 'PENDING' | 'IN_PROGRESS' | 'ASSIGNED' | 'COMPLETED' | 'TIMED_OUT';
};

declare type UserFormTemplate = {
    name?: string;
    version?: number;
};

declare type HumanTaskDefinition = {
    assignmentCompletionStrategy?: 'LEAVE_OPEN' | 'TERMINATE';
    assignments?: Array<HumanTaskAssignment>;
    taskTriggers?: Array<HumanTaskTrigger>;
    userFormTemplate?: UserFormTemplate;
};

declare type HumanTaskEntry = {
    assignee?: HumanTaskUser;
    claimant?: HumanTaskUser;
    createdBy?: string;
    createdOn?: number;
    definitionName?: string;
    displayName?: string;
    humanTaskDef?: HumanTaskDefinition;
    input?: Record<string, any>;
    output?: Record<string, any>;
    state?: 'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'TIMED_OUT' | 'DELETED';
    taskId?: string;
    taskRefName?: string;
    updatedBy?: string;
    updatedOn?: number;
    workflowId?: string;
    workflowName?: string;
};

declare type HumanTaskSearch = {
    assignees?: Array<HumanTaskUser>;
    claimants?: Array<HumanTaskUser>;
    definitionNames?: Array<string>;
    taskOutputQuery?: string;
    taskInputQuery?: string;
    searchType?: 'ADMIN' | 'INBOX';
    size?: number;
    start?: number;
    states?: Array<'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'TIMED_OUT' | 'DELETED'>;
    taskRefNames?: Array<string>;
    workflowNames?: Array<string>;
};

declare type HumanTaskSearchResult = {
    results?: Array<HumanTaskEntry>;
    totalHits?: number;
};

declare type HumanTaskTemplate = {
    createdBy?: string;
    createdOn?: number;
    jsonSchema: Record<string, any>;
    name: string;
    templateUI: Record<string, any>;
    updatedBy?: string;
    updatedOn?: number;
    version: number;
};

declare class HumanTaskService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * If the workflow is disconnected from tasks, this API can be used to clean up (in bulk)
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    deleteTaskFromHumanTaskRecords(requestBody: Array<string>): CancelablePromise<any>;
    /**
     * If the workflow is disconnected from tasks, this API can be used to clean up
     * @param taskId
     * @returns any OK
     * @throws ApiError
     */
    deleteTaskFromHumanTaskRecords1(taskId: string): CancelablePromise<any>;
    /**
     * Search human tasks
     * @param requestBody
     * @returns HumanTaskSearchResult OK
     * @throws ApiError
     */
    search(requestBody: HumanTaskSearch): CancelablePromise<HumanTaskSearchResult>;
    /**
     * Update task output, optionally complete
     * @param workflowId
     * @param taskRefName
     * @param requestBody
     * @param complete
     * @param iteration Populate this value if your task is in a loop and you want to update a specific iteration. If its not in a loop OR if you want to just update the latest iteration, leave this as empty
     * @returns any OK
     * @throws ApiError
     */
    updateTaskOutputByRef(workflowId: string, taskRefName: string, requestBody: Record<string, any>, complete?: boolean, iteration?: Array<number>): CancelablePromise<any>;
    /**
     * Get a task
     * @param taskId
     * @returns HumanTaskEntry OK
     * @throws ApiError
     */
    getTask1(taskId: string): CancelablePromise<HumanTaskEntry>;
    /**
     * Claim a task by authenticated Conductor user
     * @param taskId
     * @param overrideAssignment
     * @returns any OK
     * @throws ApiError
     */
    claimTask(taskId: string, overrideAssignment?: boolean, withTemplate?: boolean): CancelablePromise<HumanTaskEntry>;
    /**
     * Claim a task to an external user
     * @param taskId
     * @param userId
     * @param overrideAssignment
     * @returns any OK
     * @throws ApiError
     */
    assignAndClaim(taskId: string, userId: string, overrideAssignment?: boolean, withTemplate?: boolean): CancelablePromise<HumanTaskEntry>;
    /**
     * Release a task without completing it
     * @param taskId
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    reassignTask(taskId: string, requestBody: Array<HumanTaskAssignment>): CancelablePromise<any>;
    /**
     * Release a task without completing it
     * @param taskId
     * @returns any OK
     * @throws ApiError
     */
    releaseTask(taskId: string): CancelablePromise<any>;
    /**
     * If a task is assigned to a user, this API can be used to skip that assignment and move to the next assignee
     * @param taskId
     * @param reason
     * @returns any OK
     * @throws ApiError
     */
    skipTask(taskId: string, reason?: string): CancelablePromise<any>;
    /**
     * Update task output, optionally complete
     * @param taskId
     * @param requestBody
     * @param complete
     * @returns any OK
     * @throws ApiError
     */
    updateTaskOutput(taskId: string, requestBody: Record<string, any>, complete?: boolean): CancelablePromise<any>;
    /**
     * List all user form templates or get templates by name, or a template by name and version
     * @param name
     * @param version
     * @returns HumanTaskTemplate OK
     * @throws ApiError
     */
    getAllTemplates(name?: string, version?: number): CancelablePromise<Array<HumanTaskTemplate>>;
    /**
     * Save user form template
     * @param requestBody
     * @param newVersion
     * @returns HumanTaskTemplate OK
     * @throws ApiError
     */
    saveTemplate(requestBody: HumanTaskTemplate, newVersion?: boolean): CancelablePromise<HumanTaskTemplate>;
    /**
     * Save user form template
     * @param requestBody
     * @param newVersion
     * @returns HumanTaskTemplate OK
     * @throws ApiError
     */
    saveTemplates(requestBody: Array<HumanTaskTemplate>, newVersion?: boolean): CancelablePromise<Array<HumanTaskTemplate>>;
    /**
     * Delete all versions of user form template by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    deleteTemplateByName(name: string): CancelablePromise<any>;
    /**
     * Delete a version of form template by name
     * @param name
     * @param version
     * @returns any OK
     * @throws ApiError
     */
    deleteTemplatesByNameAndVersion(name: string, version: number): CancelablePromise<any>;
    /**
     * Get user form template by name and version
     * @param name
     * @param version
     * @returns HumanTaskTemplate OK
     * @throws ApiError
     */
    getTemplateByNameAndVersion(name: string, version: number): CancelablePromise<HumanTaskTemplate>;
}

declare class HumanTaskResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get Conductor task by id (for human tasks only)
     * @param taskId
     * @returns Task OK
     * @throws ApiError
     */
    getConductorTaskById(taskId: string): CancelablePromise<Task>;
}

interface ConductorClientAPIConfig extends Omit<OpenAPIConfig, "BASE"> {
    serverUrl: string;
    useEnvVars: boolean;
}
declare class ConductorClient {
    readonly eventResource: EventResourceService;
    readonly healthCheckResource: HealthCheckResourceService;
    readonly metadataResource: MetadataResourceService;
    readonly schedulerResource: SchedulerResourceService;
    readonly taskResource: TaskResourceService;
    readonly tokenResource: TokenResourceService;
    readonly workflowBulkResource: WorkflowBulkResourceService;
    readonly workflowResource: WorkflowResourceService;
    readonly humanTask: HumanTaskService;
    readonly humanTaskResource: HumanTaskResourceService;
    readonly request: BaseHttpRequest;
    token?: string | Resolver<string>;
    constructor(config?: Partial<ConductorClientAPIConfig>, requestHandler?: ConductorHttpRequest);
    stop(): void;
}

declare type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

declare type HTScrollableSearchResultHumanTaskEntry = {
    queryId?: string;
    results?: Array<HumanTaskEntry>;
};

declare type TimeoutPolicy = {
    type: string;
};

declare type Terminate = (TimeoutPolicy & {
    timeoutSeconds?: number;
});

/**
 * Functional interface for defining a worker implementation that processes tasks from a conductor queue.
 *
 * @remarks
 * Optional items allow overriding properties on a per-worker basis. Items not overridden
 * here will be inherited from the `TaskManager` options.
 */
interface ConductorWorker {
    taskDefName: string;
    execute: (task: Task) => Promise<Omit<TaskResult, "workflowInstanceId" | "taskId">>;
    domain?: string;
    concurrency?: number;
    pollInterval?: number;
}

interface ConductorLogger {
    info(...args: any): void;
    error(...args: any): void;
    debug(...args: any): void;
}
declare type ConductorLogLevel = keyof typeof LOG_LEVELS;
interface DefaultLoggerConfig {
    level?: ConductorLogLevel;
    tags?: Object[];
}
declare const LOG_LEVELS: {
    readonly DEBUG: 10;
    readonly INFO: 30;
    readonly ERROR: 60;
};
declare class DefaultLogger implements ConductorLogger {
    private readonly tags;
    private readonly level;
    constructor(config?: DefaultLoggerConfig);
    private log;
    info: (...args: any) => void;
    debug: (...args: any) => void;
    error: (...args: any) => void;
}
declare const noopLogger: ConductorLogger;

interface CommonTaskDef {
    name: string;
    taskReferenceName: string;
}
declare enum TaskType {
    START = "START",
    SIMPLE = "SIMPLE",
    DYNAMIC = "DYNAMIC",
    FORK_JOIN = "FORK_JOIN",
    FORK_JOIN_DYNAMIC = "FORK_JOIN_DYNAMIC",
    DECISION = "DECISION",
    SWITCH = "SWITCH",
    JOIN = "JOIN",
    DO_WHILE = "DO_WHILE",
    SUB_WORKFLOW = "SUB_WORKFLOW",
    EVENT = "EVENT",
    WAIT = "WAIT",
    USER_DEFINED = "USER_DEFINED",
    HTTP = "HTTP",
    LAMBDA = "LAMBDA",
    INLINE = "INLINE",
    EXCLUSIVE_JOIN = "EXCLUSIVE_JOIN",
    TERMINAL = "TERMINAL",
    TERMINATE = "TERMINATE",
    KAFKA_PUBLISH = "KAFKA_PUBLISH",
    JSON_JQ_TRANSFORM = "JSON_JQ_TRANSFORM",
    SET_VARIABLE = "SET_VARIABLE"
}
declare type TaskDefTypes = SimpleTaskDef | DoWhileTaskDef | EventTaskDef | ForkJoinTaskDef | ForkJoinDynamicDef | HttpTaskDef | InlineTaskDef | JsonJQTransformTaskDef | KafkaPublishTaskDef | SetVariableTaskDef | SubWorkflowTaskDef | SwitchTaskDef | TerminateTaskDef | JoinTaskDef | WaitTaskDef;
interface DoWhileTaskDef extends CommonTaskDef {
    inputParameters: Record<string, unknown>;
    type: TaskType.DO_WHILE;
    startDelay?: number;
    optional?: boolean;
    asyncComplete?: boolean;
    loopCondition: string;
    loopOver: TaskDefTypes[];
}
interface EventTaskDef extends CommonTaskDef {
    type: TaskType.EVENT;
    sink: string;
    asyncComplete?: boolean;
}
interface ForkJoinTaskDef extends CommonTaskDef {
    type: TaskType.FORK_JOIN;
    inputParameters?: Record<string, string>;
    forkTasks: Array<Array<TaskDefTypes>>;
}
interface JoinTaskDef extends CommonTaskDef {
    type: TaskType.JOIN;
    inputParameters?: Record<string, string>;
    joinOn: string[];
    optional?: boolean;
    asyncComplete?: boolean;
}
interface ForkJoinDynamicDef extends CommonTaskDef {
    inputParameters: {
        dynamicTasks: any;
        dynamicTasksInput: any;
    };
    type: TaskType.FORK_JOIN_DYNAMIC;
    dynamicForkTasksParam: string;
    dynamicForkTasksInputParamName: string;
    startDelay?: number;
    optional?: boolean;
    asyncComplete?: boolean;
}
interface HttpInputParameters {
    uri: string;
    method: "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD";
    accept?: string;
    contentType?: string;
    headers?: Record<string, string>;
    body?: unknown;
    connectionTimeOut?: number;
    readTimeOut?: string;
}
interface HttpTaskDef extends CommonTaskDef {
    inputParameters: {
        [x: string]: unknown;
        http_request: HttpInputParameters;
    };
    type: TaskType.HTTP;
}
interface InlineTaskInputParameters {
    evaluatorType: "javascript" | "graaljs";
    expression: string;
    [x: string]: unknown;
}
interface InlineTaskDef extends CommonTaskDef {
    type: TaskType.INLINE;
    inputParameters: InlineTaskInputParameters;
}
interface ContainingQueryExpression {
    queryExpression: string;
    [x: string | number | symbol]: unknown;
}
interface JsonJQTransformTaskDef extends CommonTaskDef {
    type: TaskType.JSON_JQ_TRANSFORM;
    inputParameters: ContainingQueryExpression;
}
interface KafkaPublishInputParameters {
    topic: string;
    value: string;
    bootStrapServers: string;
    headers: Record<string, string>;
    key: string;
    keySerializer: string;
}
interface KafkaPublishTaskDef extends CommonTaskDef {
    inputParameters: {
        kafka_request: KafkaPublishInputParameters;
    };
    type: TaskType.KAFKA_PUBLISH;
}
interface SetVariableTaskDef extends CommonTaskDef {
    type: TaskType.SET_VARIABLE;
    inputParameters: Record<string, unknown>;
}
interface SimpleTaskDef extends CommonTaskDef {
    type: TaskType.SIMPLE;
    inputParameters?: Record<string, unknown>;
}
interface SubWorkflowTaskDef extends CommonTaskDef {
    type: TaskType.SUB_WORKFLOW;
    inputParameters?: Record<string, unknown>;
    subWorkflowParam: {
        name: string;
        version?: number;
        taskToDomain?: Record<string, string>;
    };
}
interface SwitchTaskDef extends CommonTaskDef {
    inputParameters: Record<string, unknown>;
    type: TaskType.SWITCH;
    decisionCases: Record<string, TaskDefTypes[]>;
    defaultCase: TaskDefTypes[];
    evaluatorType: "value-param" | "javascript";
    expression: string;
}
interface TerminateTaskDef extends CommonTaskDef {
    inputParameters: {
        terminationStatus: "COMPLETED" | "FAILED";
        workflowOutput?: Record<string, string>;
        terminationReason?: string;
    };
    type: TaskType.TERMINATE;
    startDelay?: number;
    optional?: boolean;
}
interface WaitTaskDef extends CommonTaskDef {
    type: TaskType.WAIT;
    inputParameters: {
        duration?: string;
        until?: string;
    };
}
interface WorkflowDef extends Omit<WorkflowDef$1, "tasks" | "version" | "inputParameters"> {
    inputParameters: string[];
    version: number;
    tasks: TaskDefTypes[];
}

declare type TaskErrorHandler = (error: Error, task?: Task) => void;
interface TaskRunnerOptions {
    workerID: string;
    domain: string | undefined;
    pollInterval?: number;
    concurrency?: number;
    batchPollingTimeout?: number;
}
interface RunnerArgs {
    worker: ConductorWorker;
    taskResource: TaskResourceService;
    options: TaskRunnerOptions;
    logger?: ConductorLogger;
    onError?: TaskErrorHandler;
    concurrency?: number;
    maxRetries?: number;
}

declare const MAX_RETRIES = 3;
declare const noopErrorHandler: TaskErrorHandler;
/**
 * Responsible for polling and executing tasks from a queue.
 *
 * Because a `poll` in conductor "pops" a task off of a conductor queue,
 * each runner participates in the poll -> work -> update loop.
 * We could potentially split this work into a separate "poller" and "worker" pools
 * but that could lead to picking up more work than the pool of workers are actually able to handle.
 *
 */
declare class TaskRunner {
    taskResource: TaskResourceService;
    worker: ConductorWorker;
    private logger;
    private options;
    errorHandler: TaskErrorHandler;
    private poller;
    private maxRetries;
    constructor({ worker, taskResource, options, logger, onError: errorHandler, maxRetries, }: RunnerArgs);
    get isPolling(): boolean;
    /**
     * Starts polling for work
     */
    startPolling: () => void;
    /**
     * Stops Polling for work
     */
    stopPolling: () => Promise<void>;
    updateOptions(options: Partial<TaskRunnerOptions>): void;
    get getOptions(): TaskRunnerOptions;
    private batchPoll;
    updateTaskWithRetry: (task: Task, taskResult: TaskResult) => Promise<void>;
    private executeTask;
    handleUnknownError: (unknownError: unknown) => void;
}

declare type TaskManagerOptions = TaskRunnerOptions;
interface TaskManagerConfig {
    logger?: ConductorLogger;
    options?: Partial<TaskManagerOptions>;
    onError?: TaskErrorHandler;
    maxRetries?: number;
}
/**
 * Responsible for initializing and managing the runners that poll and work different task queues.
 */
declare class TaskManager {
    private workerRunners;
    private readonly client;
    private readonly logger;
    private readonly errorHandler;
    private workers;
    readonly options: Required<TaskManagerOptions>;
    private polling;
    private maxRetries;
    constructor(client: ConductorClient, workers: Array<ConductorWorker>, config?: TaskManagerConfig);
    private workerManagerWorkerOptions;
    get isPolling(): boolean;
    updatePollingOptionForWorker: (workerTaskDefName: string, options: Partial<TaskManagerOptions>) => void;
    /**
     * new options will get merged to existing options
     * @param options new options to update polling options
     */
    updatePollingOptions: (options: Partial<TaskManagerOptions>) => void;
    sanityCheck: () => void;
    /**
     * Start polling for tasks
     */
    startPolling: () => void;
    /**
     * Stops polling for tasks
     */
    stopPolling: () => Promise<void>;
}

declare class ConductorError extends Error {
    private _trace;
    private __proto__;
    constructor(message?: string, innerError?: Error);
}
declare type TaskResultStatus = NonNullable<TaskResult['status']>;

declare type TaskFinderPredicate = (task: Task) => boolean;
declare const completedTaskMatchingType: (taskType: string) => TaskFinderPredicate;
declare class WorkflowExecutor {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Will persist a workflow in conductor
     * @param override If true will override the existing workflow with the definition
     * @param workflow Complete workflow definition
     * @returns null
     */
    registerWorkflow(override: boolean, workflow: WorkflowDef): Promise<void>;
    /**
     * Takes a StartWorkflowRequest. returns a Promise<string> with the workflowInstanceId of the running workflow
     * @param workflowRequest
     * @returns
     */
    startWorkflow(workflowRequest: StartWorkflowRequest): Promise<string>;
    /**
     * Execute a workflow synchronously. returns a Promise<WorkflowRun> with details of the running workflow
     * @param workflowRequest
     * @returns
     */
    executeWorkflow(workflowRequest: StartWorkflowRequest, name: string, version: number, requestId: string, waitUntilTaskRef?: string): Promise<WorkflowRun>;
    startWorkflows(workflowsRequest: StartWorkflowRequest[]): Promise<string>[];
    goBackToTask(workflowInstanceId: string, taskFinderPredicate: TaskFinderPredicate, rerunWorkflowRequestOverrides?: Partial<RerunWorkflowRequest>): Promise<void>;
    goBackToFirstTaskMatchingType(workflowInstanceId: string, taskType: string): Promise<void>;
    /**
     * Takes an workflowInstanceId and an includeTasks and an optional retry parameter returns the whole execution status.
     * If includeTasks flag is provided. Details of tasks execution will be returned as well,
     * retry specifies the amount of retrys before throwing an error.
     *
     * @param workflowInstanceId
     * @param includeTasks
     * @param retry
     * @returns
     */
    getWorkflow(workflowInstanceId: string, includeTasks: boolean, retry?: number): Promise<Workflow>;
    /**
     *  Returns a summary of the current workflow status.
     *
     * @param workflowInstanceId current running workflow
     * @param includeOutput flag to include output
     * @param includeVariables flag to include variable
     * @returns Promise<WorkflowStatus>
     */
    getWorkflowStatus(workflowInstanceId: string, includeOutput: boolean, includeVariables: boolean): Promise<WorkflowStatus>;
    /**
     *  Returns a summary of the current workflow status.
     *
     * @param workflowInstanceId current running workflow
     * @param includeOutput flag to include output
     * @param includeVariables flag to include variable
     * @returns Promise<WorkflowStatus>
     */
    getExecution(workflowInstanceId: string, includeTasks?: boolean): Promise<Workflow>;
    /**
     * Pauses a running workflow
     * @param workflowInstanceId current workflow execution
     * @returns
     */
    pause(workflowInstanceId: string): Promise<void>;
    /**
     * Reruns workflowInstanceId workflow. with new parameters
     *
     * @param workflowInstanceId current workflow execution
     * @param rerunWorkflowRequest Rerun Workflow Execution Request
     * @returns
     */
    reRun(workflowInstanceId: string, rerunWorkflowRequest?: Partial<RerunWorkflowRequest>): Promise<string>;
    /**
     * Restarts workflow with workflowInstanceId, if useLatestDefinition uses last defintion
     * @param workflowInstanceId
     * @param useLatestDefinitions
     * @returns
     */
    restart(workflowInstanceId: string, useLatestDefinitions: boolean): Promise<void>;
    /**
     * Resumes a previously paused execution
     *
     * @param workflowInstanceId Running workflow workflowInstanceId
     * @returns
     */
    resume(workflowInstanceId: string): Promise<void>;
    /**
     * Retrys workflow from last failing task
     * if resumeSubworkflowTasks is true will resume tasks in spawned subworkflows
     *
     * @param workflowInstanceId
     * @param resumeSubworkflowTasks
     * @returns
     */
    retry(workflowInstanceId: string, resumeSubworkflowTasks: boolean): Promise<void>;
    /**
     * Searches for existing workflows given the following querys
     *
     * @param start
     * @param size
     * @param query
     * @param freeText
     * @param sort
     * @param skipCache
     * @returns
     */
    search(start: number, size: number, query: string, freeText: string, sort?: string, skipCache?: boolean): Promise<ScrollableSearchResultWorkflowSummary>;
    /**
     * Skips a task of a running workflow.
     * by providing a skipTaskRequest you can set the input and the output of the skipped tasks
     * @param workflowInstanceId
     * @param taskReferenceName
     * @param skipTaskRequest
     * @returns
     */
    skipTasksFromWorkflow(workflowInstanceId: string, taskReferenceName: string, skipTaskRequest: Partial<SkipTaskRequest>): Promise<void>;
    /**
     * Takes an workflowInstanceId, and terminates a running workflow
     * @param workflowInstanceId
     * @param reason
     * @returns
     */
    terminate(workflowInstanceId: string, reason: string): Promise<void>;
    /**
     * Takes a taskId and a workflowInstanceId. Will update the task for the corresponding taskId
     * @param taskId
     * @param workflowInstanceId
     * @param taskStatus
     * @param taskOutput
     * @returns
     */
    updateTask(taskId: string, workflowInstanceId: string, taskStatus: TaskResultStatus, outputData: Record<string, any>): Promise<string>;
    /**
     * Updates a task by reference Name
     * @param taskReferenceName
     * @param workflowInstanceId
     * @param status
     * @param taskOutput
     * @returns
     */
    updateTaskByRefName(taskReferenceName: string, workflowInstanceId: string, status: TaskResultStatus, taskOutput: Record<string, any>): Promise<string>;
    /**
     *
     * @param taskId
     * @returns
     */
    getTask(taskId: string): Promise<Task>;
}

declare type PollIntervalOptions = {
    pollInterval: number;
    maxPollTimes: number;
};
declare class HumanExecutor {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * @deprecated use search instead
     * Takes a set of filter parameters. return matches of human tasks for that set of parameters
     * @param state
     * @param assignee
     * @param assigneeType
     * @param claimedBy
     * @param taskName
     * @param freeText
     * @param includeInputOutput
     * @returns
     */
    getTasksByFilter(state: "PENDING" | "ASSIGNED" | "IN_PROGRESS" | "COMPLETED" | "TIMED_OUT", assignee?: string, assigneeType?: "EXTERNAL_USER" | "EXTERNAL_GROUP" | "CONDUCTOR_USER" | "CONDUCTOR_GROUP", claimedBy?: string, taskName?: string, taskInputQuery?: string, taskOutputQuery?: string): Promise<HumanTaskEntry[]>;
    /**
     * Takes a set of filter parameters. return matches of human tasks for that set of parameters
     * @param state
     * @param assignee
     * @param assigneeType
     * @param claimedBy
     * @param taskName
     * @param freeText
     * @param includeInputOutput
     * @returns Promise<HumanTaskEntry[]>
     */
    search(searchParams: Partial<HumanTaskSearch>): Promise<HumanTaskEntry[]>;
    /**
     * Takes a set of filter parameters. An polling interval options. will poll until the task returns a result
     * @param state
     * @param assignee
     * @param assigneeType
     * @param claimedBy
     * @param taskName
     * @param freeText
     * @param includeInputOutput
     * @returns Promise<HumanTaskEntry[]>
     */
    pollSearch(searchParams: Partial<HumanTaskSearch>, { pollInterval, maxPollTimes, }?: PollIntervalOptions): Promise<HumanTaskEntry[]>;
    /**
     * Returns task for a given task id
     * @param taskId
     * @returns
     */
    getTaskById(taskId: string): Promise<HumanTaskEntry>;
    /**
     * Assigns taskId to assignee. If the task is already assigned to another user, this will fail.
     * @param taskId
     * @param assignee
     * @returns
     */
    claimTaskAsExternalUser(taskId: string, assignee: string, options?: Record<string, boolean>): Promise<HumanTaskEntry>;
    /**
     * Claim task as conductor user
     * @param taskId
     * @returns
     */
    claimTaskAsConductorUser(taskId: string, options?: Record<string, boolean>): Promise<HumanTaskEntry>;
    /**
     * Claim task as conductor user
     * @param taskId
     * @param assignee
     * @returns
     */
    releaseTask(taskId: string): Promise<void>;
    /**
     * Returns a HumanTaskTemplateEntry for a given name and version
     * @param templateId
     * @returns
     */
    getTemplateByNameVersion(name: string, version: number): Promise<HumanTaskTemplate>;
    /**
     * @deprecated use getTemplate instead. name will be used as id here with version 1
     * Returns a HumanTaskTemplateEntry for a given templateId
     * @param templateId
     * @returns
     */
    getTemplateById(templateNameVersionOne: string): Promise<HumanTaskTemplate>;
    /**
     * Takes a taskId and a partial body. will update with given body
     * @param taskId
     * @param requestBody
     */
    updateTaskOutput(taskId: string, requestBody: Record<string, Record<string, any>>): Promise<void>;
    /**
     * Takes a taskId and an optional partial body. will complete the task with the given body
     * @param taskId
     * @param requestBody
     */
    completeTask(taskId: string, requestBody?: Record<string, Record<string, any>>): Promise<void>;
}

declare const doWhileTask: (taskRefName: string, terminationCondition: string, tasks: TaskDefTypes[]) => DoWhileTaskDef;
declare const newLoopTask: (taskRefName: string, iterations: number, tasks: TaskDefTypes[]) => DoWhileTaskDef;

declare const dynamicForkTask: (taskReferenceName: string, preForkTasks?: TaskDefTypes[], dynamicTasksInput?: string) => ForkJoinDynamicDef;

declare const eventTask: (taskReferenceName: string, eventPrefix: string, eventSuffix: string) => EventTaskDef;
declare const sqsEventTask: (taskReferenceName: string, queueName: string) => EventTaskDef;
declare const conductorEventTask: (taskReferenceName: string, eventName: string) => EventTaskDef;

declare const forkTask: (taskReferenceName: string, forkTasks: TaskDefTypes[]) => ForkJoinTaskDef;
declare const forkTaskJoin: (taskReferenceName: string, forkTasks: TaskDefTypes[]) => [ForkJoinTaskDef, JoinTaskDef];

declare const httpTask: (taskReferenceName: string, inputParameters: HttpInputParameters) => HttpTaskDef;

declare const inlineTask: (taskReferenceName: string, script: string, evaluatorType?: "javascript" | "graaljs") => InlineTaskDef;

declare const joinTask: (taskReferenceName: string, joinOn: string[]) => JoinTaskDef;

declare const jsonJqTask: (taskReferenceName: string, script: string) => JsonJQTransformTaskDef;

declare const kafkaPublishTask: (taskReferenceName: string, kafka_request: KafkaPublishInputParameters) => KafkaPublishTaskDef;

declare const setVariableTask: (taskReferenceName: string, inputParameters: Record<string, unknown>) => SetVariableTaskDef;

declare const simpleTask: (taskReferenceName: string, name: string, inputParameters: Record<string, unknown>) => SimpleTaskDef;

declare const subWorkflowTask: (taskReferenceName: string, workflowName: string, version?: number | undefined) => SubWorkflowTaskDef;

declare const switchTask: (taskReferenceName: string, expression: string, decisionCases?: Record<string, TaskDefTypes[]>, defaultCase?: TaskDefTypes[]) => SwitchTaskDef;

declare const taskDefinition: ({ name, ownerApp, description, retryCount, timeoutSeconds, inputKeys, outputKeys, timeoutPolicy, retryLogic, retryDelaySeconds, responseTimeoutSeconds, concurrentExecLimit, inputTemplate, rateLimitPerFrequency, rateLimitFrequencyInSeconds, ownerEmail, pollTimeoutSeconds, backoffScaleFactor, }: TaskDef) => TaskDef;

declare const terminateTask: (taskReferenceName: string, status: "COMPLETED" | "FAILED", terminationReason?: string | undefined) => TerminateTaskDef;

declare const waitTaskDuration: (taskReferenceName: string, duration: string) => WaitTaskDef;
declare const waitTaskUntil: (taskReferenceName: string, until: string) => WaitTaskDef;

declare const workflow: (name: string, tasks: TaskDefTypes[]) => WorkflowDef;

/**
 * Takes an optional partial SimpleTaskDef
 * generates a task replacing default values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSimpleTask: (overrides?: Partial<SimpleTaskDef>) => SimpleTaskDef;

/**
 * Takes an optional partial EventTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateEventTask: (overrides?: Partial<EventTaskDef>) => EventTaskDef;

declare type TaskDefTypesGen = SimpleTaskDef | DoWhileTaskDefGen | EventTaskDef | ForkJoinTaskDefGen | ForkJoinDynamicDef | HttpTaskDef | InlineTaskDefGen | JsonJQTransformTaskDef | KafkaPublishTaskDef | SetVariableTaskDef | SubWorkflowTaskDef | SwitchTaskDefGen | TerminateTaskDef | JoinTaskDef | WaitTaskDef;
interface WorkflowDefGen extends Omit<WorkflowDef, "tasks"> {
    tasks: Partial<TaskDefTypesGen>[];
}
declare type ForkJoinTaskDefGen = Omit<ForkJoinTaskDef, "forkTasks"> & {
    forkTasks: Array<Array<Partial<TaskDefTypesGen>>>;
};
declare type SwitchTaskDefGen = Omit<SwitchTaskDef, "decisionCases" | "defaultCase"> & {
    decisionCases: Record<string, Partial<TaskDefTypesGen>[]>;
    defaultCase: Partial<TaskDefTypesGen>[];
};
declare type DoWhileTaskDefGen = Omit<DoWhileTaskDef, "loopOver"> & {
    loopOver: Partial<TaskDefTypesGen>[];
};
interface InlineTaskInputParametersGen extends Omit<InlineTaskInputParameters, "expression"> {
    expression: string | Function;
}
interface InlineTaskDefGen extends Omit<InlineTaskDef, "inputParameters"> {
    inputParameters: InlineTaskInputParametersGen;
}
declare type NestedTaskMapper = {
    (tasks: Partial<TaskDefTypesGen>[]): TaskDefTypes[];
};

declare const generateJoinTask: (overrides?: Partial<JoinTaskDef>) => JoinTaskDef;

/**
 * Takes an optional partial HttpTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateHTTPTask: (overrides?: Partial<HttpTaskDef>) => HttpTaskDef;

/**
 * Takes an optional partial InlineTaskDefGen
 * generates a task replacing default/fake values with provided overrides
 *
 * <b>note</b> that the inputParameters.expression can be either a string containing javascript
 * or a function thar returns an ES5 function
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateInlineTask: (override?: Partial<InlineTaskDefGen>) => InlineTaskDef;

/**
 * Takes an optional partial JsonJQTransformTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateJQTransformTask: (overrides?: Partial<JsonJQTransformTaskDef>) => JsonJQTransformTaskDef;

/**
 * Takes an optional partial KafkaPublishTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateKafkaPublishTask: (overrides?: Partial<KafkaPublishTaskDef>) => KafkaPublishTaskDef;

/**
 * Takes an optional partial SubWorkflowTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSubWorkflowTask: (overrides?: Partial<SubWorkflowTaskDef>) => SubWorkflowTaskDef;

/**
 * Takes an optional partial SetVariableTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSetVariableTask: (overrides?: Partial<SetVariableTaskDef>) => SetVariableTaskDef;

/**
 * Takes an optional partial TerminateTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateTerminateTask: (overrides?: Partial<TerminateTaskDef>) => TerminateTaskDef;

/**
 * Takes an optional partial WaitTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateWaitTask: (overrides?: Partial<WaitTaskDef>) => WaitTaskDef;

declare const taskGenMapper: (tasks: Partial<TaskDefTypesGen>[]) => TaskDefTypes[];
/**
 * Takes an optional partial WorkflowDefGen
 * generates a workflow replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generate: (overrides: Partial<WorkflowDefGen>) => WorkflowDef;

/**
 * Takes an optional partial SwitchTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateSwitchTask: (overrides?: Partial<SwitchTaskDefGen>, nestedTasksMapper?: NestedTaskMapper) => SwitchTaskDef;
/**
 * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateDoWhileTask: (overrides?: Partial<DoWhileTaskDefGen>, nestedTasksMapper?: NestedTaskMapper) => DoWhileTaskDef;
/**
 * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateForkJoinTask: (overrides?: Partial<ForkJoinTaskDefGen>, nestedMapper?: NestedTaskMapper) => ForkJoinTaskDef;

declare class SchedulerClient {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Create or update a schedule for a specified workflow with a corresponding start workflow request
     * @param requestBody
     * @returns
     */
    saveSchedule(param: SaveScheduleRequest): Promise<void>;
    /**
     * Searches for existing scheduler execution based on below parameters
     *
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowScheduleExecutionModel
     */
    search(start: number, size: number, sort: string | undefined, freeText: string, query: string): Promise<SearchResultWorkflowScheduleExecutionModel>;
    /**
     * Get an existing schedule by name
     * @param name
     * @returns SaveScheduleRequest
     */
    getSchedule(name: string): Promise<SaveScheduleRequest>;
    /**
     * Pauses an existing schedule by name
     * @param name
     * @returns
     */
    pauseSchedule(name: string): Promise<void>;
    /**
     * Resume a paused schedule by name
     *
     * @param name
     * @returns
     */
    resumeSchedule(name: string): Promise<void>;
    /**
     * Deletes an existing scheduler execution by name
     *
     * @param name
     * @returns
     */
    deleteSchedule(name: string): Promise<void>;
    /**
     * Get all existing workflow schedules and optionally filter by workflow name
     * @param workflowName
     * @returns Array<WorkflowSchedule>
     */
    getAllSchedules(workflowName?: string): Promise<Array<WorkflowSchedule>>;
    /**
     * Get list of the next x (default 3, max 5) execution times for a scheduler
     * @param cronExpression
     * @param scheduleStartTime
     * @param scheduleEndTime
     * @param limit
     * @returns number OK
     * @throws ApiError
     */
    getNextFewSchedules(cronExpression: string, scheduleStartTime?: number, scheduleEndTime?: number, limit?: number): Promise<Array<number[]>>;
    /**
     * Pause all scheduling in a single conductor server instance (for debugging only)
     * @returns any OK
     * @throws ApiError
     */
    pauseAllSchedules(): Promise<void>;
    /**
     * Requeue all execution records
     * @returns any OK
     * @throws ApiError
     */
    requeueAllExecutionRecords(): Promise<void>;
    /**
     * Resume all scheduling
     * @returns any OK
     * @throws ApiError
     */
    resumeAllSchedules(): Promise<void>;
}

declare class TaskClient {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Searches for existing scheduler execution based on below parameters
     *
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowScheduleExecutionModel
     */
    search(start: number, size: number, sort: string | undefined, freeText: string, query: string): Promise<SearchResultTask>;
    /**
     * Get an existing schedule by Id
     * @param taskId
     * @returns Task
     */
    getTask(taskId: string): Promise<Task>;
    /**
     * Update task result status
     *
     * @param workflowId
     * @param taskReferenceName
     * @param status
     * @param outputData
     * @param workerId
     * @returns
     */
    updateTaskResult(workflowId: string, taskReferenceName: string, status: TaskResultStatus, outputData: Record<string, unknown>): Promise<TaskResult>;
}

declare class TemplateClient {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Register a new human task template
     *
     * @param template
     * @returns
     */
    registerTemplate(template: HumanTaskTemplate, asNewVersion?: boolean): Promise<HumanTaskTemplate>;
}

declare class MetadataClient {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Unregisters an existing task definition by name
     *
     * @param name
     * @returns
     */
    unregisterTask(name: string): Promise<void>;
    /**
     * Registers a new task definition
     *
     * @param taskDef
     * @returns
     */
    registerTask(taskDef: TaskDef): Promise<void>;
    /**
     * Update an existing task definition
     *
     * @param taskDef
     * @returns
     */
    updateTask(taskDef: TaskDef): Promise<void>;
    /**
     * Creates or updates (overwrite: true) a workflow definition
     *
     * @param workflowDef
     * @param overwrite
     * @returns
     */
    registerWorkflowDef(workflowDef: WorkflowDef$1, overwrite?: boolean): any;
}

declare type FetchFn<T = RequestInit, R extends {
    json: () => Promise<any>;
} = Response> = (input: RequestInfo, init?: T) => Promise<R>;
declare type OrkesApiConfig = ConductorClientAPIConfig & GenerateTokenRequest;

/**
 * Takes a config with keyId and keySecret returns a promise with an instance of ConductorClient
 *
 * @param config ConductorClientConfig with keyId and keySecret
 * @param requestHandler (optional) ConductorHttpRequest handler
 * @returns
 */
declare const orkesConductorClient: (config?: Partial<OrkesApiConfig> | undefined, requestHandler?: ConductorHttpRequest) => Promise<ConductorClient>;

declare class AuthConductorClient extends ConductorClient {
    intervalId?: NodeJS.Timeout;
    constructor(config?: Partial<ConductorClientAPIConfig>, requestHandler?: ConductorHttpRequest);
    /**
     * Stops the interval that refreshes the token
     */
    stop(): void;
}
declare const baseOrkesConductorClient: <T = RequestInit, R extends {
    json: () => Promise<any>;
} = Response>(fetchFn: FetchFn<T, R>, baseRequestHandler?: ConductorHttpRequest) => (config?: Partial<OrkesApiConfig> | undefined, requestHandler?: ConductorHttpRequest) => Promise<ConductorClient>;

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
declare const request: <T>(config: OpenAPIConfig, options: ApiRequestOptions, fetchFn?: FetchFn) => CancelablePromise<T>;

export { Action, ApiError, ApiRequestOptions, ApiResult, AuthConductorClient, BaseHttpRequest, CancelError, CancelablePromise, CommonTaskDef, ConductorClient, ConductorClientAPIConfig, ConductorError, ConductorHttpRequest, ConductorLogLevel, ConductorLogger, ConductorWorker, DefaultLogger, DefaultLoggerConfig, DoWhileTaskDef, EventHandler, EventResourceService, EventTaskDef, ExternalStorageLocation, FetchFn, ForkJoinDynamicDef, ForkJoinTaskDef, GenerateTokenRequest, HTScrollableSearchResultHumanTaskEntry, HealthCheckResourceService, HttpInputParameters, HttpTaskDef, HumanExecutor, HumanTaskAssignment, HumanTaskDefinition, HumanTaskEntry, HumanTaskSearch, HumanTaskSearchResult, HumanTaskTemplate, HumanTaskTrigger, HumanTaskUser, InlineTaskDef, InlineTaskInputParameters, JoinTaskDef, JsonJQTransformTaskDef, KafkaPublishInputParameters, KafkaPublishTaskDef, MAX_RETRIES, MetadataClient, MetadataResourceService, OnCancel, OpenAPIConfig, OrkesApiConfig, PollData, RequestType, RerunWorkflowRequest, Response$1 as Response, RunnerArgs, SaveScheduleRequest, SchedulerClient, SchedulerResourceService, ScrollableSearchResultWorkflowSummary, SearchResultTask, SearchResultTaskSummary, SearchResultWorkflow, SearchResultWorkflowScheduleExecutionModel, SearchResultWorkflowSummary, SetVariableTaskDef, SimpleTaskDef, SkipTaskRequest, StartWorkflow, StartWorkflowRequest, SubWorkflowParams, SubWorkflowTaskDef, SwitchTaskDef, Task, TaskClient, TaskDef, TaskDefTypes, TaskDetails, TaskErrorHandler, TaskExecLog, TaskFinderPredicate, TaskManager, TaskManagerConfig, TaskManagerOptions, TaskResourceService, TaskResult, TaskResultStatus, TaskRunner, TaskRunnerOptions, TaskSummary, TaskType, TemplateClient, Terminate, TerminateTaskDef, TimeoutPolicy, TokenResourceService, UserFormTemplate, WaitTaskDef, Workflow, WorkflowBulkResourceService, WorkflowDef, WorkflowExecutor, WorkflowResourceService, WorkflowSchedule, WorkflowScheduleExecutionModel, WorkflowStatus, WorkflowSummary, WorkflowTask, baseOrkesConductorClient, completedTaskMatchingType, conductorEventTask, doWhileTask, dynamicForkTask, eventTask, forkTask, forkTaskJoin, generate, generateDoWhileTask, generateEventTask, generateForkJoinTask, generateHTTPTask, generateInlineTask, generateJQTransformTask, generateJoinTask, generateKafkaPublishTask, generateSetVariableTask, generateSimpleTask, generateSubWorkflowTask, generateSwitchTask, generateTerminateTask, generateWaitTask, httpTask, inlineTask, joinTask, jsonJqTask, kafkaPublishTask, newLoopTask, noopErrorHandler, noopLogger, orkesConductorClient, request, setVariableTask, simpleTask, sqsEventTask, subWorkflowTask, switchTask, taskDefinition, taskGenMapper, terminateTask, waitTaskDuration, waitTaskUntil, workflow };
