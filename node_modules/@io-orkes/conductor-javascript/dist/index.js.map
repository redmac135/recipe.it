{"version":3,"sources":["../index.ts","../src/common/ConductorLogger.ts","../src/common/types.ts","../src/common/open-api/services/EventResourceService.ts","../src/common/open-api/services/HealthCheckResourceService.ts","../src/common/open-api/services/MetadataResourceService.ts","../src/common/open-api/services/SchedulerResourceService.ts","../src/common/open-api/services/TaskResourceService.ts","../src/common/open-api/services/TokenResourceService.ts","../src/common/open-api/services/WorkflowBulkResourceService.ts","../src/common/open-api/services/WorkflowResourceService.ts","../src/common/open-api/core/ApiError.ts","../src/common/open-api/core/CancelablePromise.ts","../src/common/open-api/core/request.ts","../src/common/open-api/services/HumanTaskService.ts","../src/common/open-api/services/HumanTaskResourceService.ts","../src/common/open-api/ConductorClient.ts","../src/common/open-api/core/BaseHttpRequest.ts","../src/task/constants.ts","../src/task/Poller.ts","../src/task/helpers.ts","../src/task/TaskRunner.ts","../src/task/TaskManager.ts","../src/core/types.ts","../src/core/helpers.ts","../src/core/executor.ts","../src/core/human.ts","../src/core/sdk/doWhile.ts","../src/core/sdk/dynamicFork.ts","../src/core/sdk/event.ts","../src/core/generators/common.ts","../src/core/generators/SimpleTask.ts","../src/core/generators/DoWhileTask.ts","../src/core/generators/EventTask.ts","../src/core/generators/ForkJoin.ts","../src/core/generators/HttpTask.ts","../src/core/generators/InlineTask.ts","../src/core/generators/JsonJQTransform.ts","../src/core/generators/KafkaTask.ts","../src/core/generators/SubWorkflowTask.ts","../src/core/generators/SetVariableTask.ts","../src/core/generators/TerminateTask.ts","../src/core/generators/WaitTask.ts","../src/core/generators/SwitchTask.ts","../src/core/generators/WorkflowGenerator.ts","../src/core/generators/ForkJoinDynamicTask.ts","../src/core/generators/generator.ts","../src/core/generators/index.ts","../src/core/sdk/forkJoin.ts","../src/core/sdk/http.ts","../src/core/sdk/inline.ts","../src/core/sdk/join.ts","../src/core/sdk/jsonJq.ts","../src/core/sdk/kafkaPublish.ts","../src/core/sdk/setVariable.ts","../src/core/sdk/simple.ts","../src/core/sdk/subWorkflow.ts","../src/core/sdk/switch.ts","../src/core/sdk/taskDefinition.ts","../src/core/sdk/terminate.ts","../src/core/sdk/wait.ts","../src/core/sdk/workflow.ts","../src/core/schedulerClient.ts","../src/core/taskClient.ts","../src/core/templateClient.ts","../src/core/metadataClient.ts","../src/orkes/BaseOrkesConductorClient.ts","../src/orkes/OrkesConductorClient.ts","../src/orkes/request/request.ts"],"sourcesContent":["export * from \"./src/task/index\";\nexport * from \"./src/common\";\nexport * from \"./src/core\";\nexport * from \"./src/orkes\";\n\n","export interface ConductorLogger {\n  info(...args: any): void\n  error(...args: any): void\n  debug(...args: any): void\n}\n\nexport type ConductorLogLevel = keyof typeof LOG_LEVELS\nexport interface DefaultLoggerConfig {\n  level?: ConductorLogLevel,\n  tags?: Object[]\n}\n\nconst LOG_LEVELS = {\n  DEBUG: 10,\n  INFO: 30,\n  ERROR: 60\n} as const\n\n\n/*\nThis provides an easy way to get up and running without worrying about configuring a logging framework.\nIdeally, users that care can easily override with any compatible logger (e.g. pino, etc)\n */\nexport class DefaultLogger implements ConductorLogger {\n  private readonly tags: Object[]\n  private readonly level: number\n\n  constructor(config: DefaultLoggerConfig = {}) {\n    const {level, tags = []} = config\n    this.tags = tags\n    if (level && level in LOG_LEVELS) {\n      this.level = LOG_LEVELS[level]\n    } else {\n      this.level = LOG_LEVELS.INFO\n    }\n  }\n\n  private log (level: ConductorLogLevel, ...args: any) {\n    let resolvedLevel: number\n    let name = level\n    if (level in LOG_LEVELS) {\n      resolvedLevel = LOG_LEVELS[level]\n    } else {\n      name = \"INFO\"\n      resolvedLevel = LOG_LEVELS.INFO\n    }\n    if (resolvedLevel >= this.level) {\n      console.log(name, ...this.tags, ...args)\n    }\n  }\n\n  info = (...args: any): void => {\n    this.log(\"INFO\", ...args)\n  }\n\n  debug = (...args: any): void => {\n    this.log(\"DEBUG\", ...args)\n  }\n\n  error =(...args: any): void => {\n    this.log(\"ERROR\", ...args)\n  }\n}\n\nexport const noopLogger: ConductorLogger = {\n  //eslint-disable-next-line\n  debug: (...args: any) => {},\n  //eslint-disable-next-line\n  info: (...args: any) => {},\n  //eslint-disable-next-line\n  error: (...args: any) => {},\n};\n","import { WorkflowDef as OriginalWorkflowDef } from \"./open-api/models/WorkflowDef\";\n\nexport interface CommonTaskDef {\n  name: string;\n  taskReferenceName: string;\n}\n\nexport enum TaskType {\n  START = \"START\",\n  SIMPLE = \"SIMPLE\",\n  DYNAMIC = \"DYNAMIC\",\n  FORK_JOIN = \"FORK_JOIN\",\n  FORK_JOIN_DYNAMIC = \"FORK_JOIN_DYNAMIC\",\n  DECISION = \"DECISION\",\n  SWITCH = \"SWITCH\",\n  JOIN = \"JOIN\",\n  DO_WHILE = \"DO_WHILE\",\n  SUB_WORKFLOW = \"SUB_WORKFLOW\",\n  EVENT = \"EVENT\",\n  WAIT = \"WAIT\",\n  USER_DEFINED = \"USER_DEFINED\",\n  HTTP = \"HTTP\",\n  LAMBDA = \"LAMBDA\",\n  INLINE = \"INLINE\",\n  EXCLUSIVE_JOIN = \"EXCLUSIVE_JOIN\",\n  TERMINAL = \"TERMINAL\",\n  TERMINATE = \"TERMINATE\",\n  KAFKA_PUBLISH = \"KAFKA_PUBLISH\",\n  JSON_JQ_TRANSFORM = \"JSON_JQ_TRANSFORM\",\n  SET_VARIABLE = \"SET_VARIABLE\",\n}\n\nexport type TaskDefTypes =\n  | SimpleTaskDef\n  | DoWhileTaskDef\n  | EventTaskDef\n  | ForkJoinTaskDef\n  | ForkJoinDynamicDef\n  | HttpTaskDef\n  | InlineTaskDef\n  | JsonJQTransformTaskDef\n  | KafkaPublishTaskDef\n  | SetVariableTaskDef\n  | SubWorkflowTaskDef\n  | SwitchTaskDef\n  | TerminateTaskDef\n  | JoinTaskDef\n  | WaitTaskDef;\n\nexport interface DoWhileTaskDef extends CommonTaskDef {\n  inputParameters: Record<string, unknown>;\n  type: TaskType.DO_WHILE;\n  startDelay?: number;\n  optional?: boolean;\n  asyncComplete?: boolean;\n  loopCondition: string;\n  loopOver: TaskDefTypes[];\n}\n\nexport interface EventTaskDef extends CommonTaskDef {\n  type: TaskType.EVENT;\n  sink: string;\n  asyncComplete?: boolean;\n}\n\nexport interface ForkJoinTaskDef extends CommonTaskDef {\n  type: TaskType.FORK_JOIN;\n  inputParameters?: Record<string, string>;\n  forkTasks: Array<Array<TaskDefTypes>>;\n}\n\nexport interface JoinTaskDef extends CommonTaskDef {\n  type: TaskType.JOIN;\n  inputParameters?: Record<string, string>;\n  joinOn: string[];\n  optional?: boolean;\n  asyncComplete?: boolean;\n}\n\nexport interface ForkJoinDynamicDef extends CommonTaskDef {\n  inputParameters: {\n    dynamicTasks: any;\n    dynamicTasksInput: any;\n  };\n  type: TaskType.FORK_JOIN_DYNAMIC;\n  dynamicForkTasksParam: string; // not string \"dynamicTasks\",\n  dynamicForkTasksInputParamName: string; // not string \"dynamicTasksInput\",\n  startDelay?: number;\n  optional?: boolean;\n  asyncComplete?: boolean;\n}\nexport interface HttpInputParameters {\n  uri: string;\n  method: \"GET\" | \"PUT\" | \"POST\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\";\n  accept?: string;\n  contentType?: string;\n  headers?: Record<string, string>;\n  body?: unknown;\n  connectionTimeOut?: number;\n  readTimeOut?: string;\n}\n\nexport interface HttpTaskDef extends CommonTaskDef {\n  inputParameters: {\n    [x: string]: unknown;\n    http_request: HttpInputParameters;\n  };\n  type: TaskType.HTTP;\n}\n\nexport interface InlineTaskInputParameters {\n  evaluatorType: \"javascript\" | \"graaljs\";\n  expression: string;\n  [x: string]: unknown;\n}\n\nexport interface InlineTaskDef extends CommonTaskDef {\n  type: TaskType.INLINE;\n  inputParameters: InlineTaskInputParameters;\n}\n\ninterface ContainingQueryExpression {\n  queryExpression: string;\n  [x: string | number | symbol]: unknown;\n}\n\nexport interface JsonJQTransformTaskDef extends CommonTaskDef {\n  type: TaskType.JSON_JQ_TRANSFORM;\n  inputParameters: ContainingQueryExpression;\n}\n\nexport interface KafkaPublishInputParameters {\n  topic: string;\n  value: string;\n  bootStrapServers: string;\n  headers: Record<string, string>;\n  key: string;\n  keySerializer: string;\n}\n\nexport interface KafkaPublishTaskDef extends CommonTaskDef {\n  inputParameters: {\n    kafka_request: KafkaPublishInputParameters;\n  };\n  type: TaskType.KAFKA_PUBLISH;\n}\n\nexport interface SetVariableTaskDef extends CommonTaskDef {\n  type: TaskType.SET_VARIABLE;\n  inputParameters: Record<string, unknown>;\n}\n\nexport interface SimpleTaskDef extends CommonTaskDef {\n  type: TaskType.SIMPLE;\n  inputParameters?: Record<string, unknown>;\n}\n\nexport interface SubWorkflowTaskDef extends CommonTaskDef {\n  type: TaskType.SUB_WORKFLOW;\n  inputParameters?: Record<string, unknown>;\n  subWorkflowParam: {\n    name: string;\n    version?: number;\n    taskToDomain?: Record<string, string>;\n  };\n}\n\nexport interface SwitchTaskDef extends CommonTaskDef {\n  inputParameters: Record<string, unknown>;\n  type: TaskType.SWITCH;\n  decisionCases: Record<string, TaskDefTypes[]>;\n  defaultCase: TaskDefTypes[];\n  evaluatorType: \"value-param\" | \"javascript\";\n  expression: string;\n}\n\nexport interface TerminateTaskDef extends CommonTaskDef {\n  inputParameters: {\n    terminationStatus: \"COMPLETED\" | \"FAILED\";\n    workflowOutput?: Record<string, string>;\n    terminationReason?: string;\n  };\n  type: TaskType.TERMINATE;\n  startDelay?: number;\n  optional?: boolean;\n}\n\nexport interface WaitTaskDef extends CommonTaskDef {\n  type: TaskType.WAIT;\n  inputParameters: {\n    duration?: string;\n    until?: string;\n  };\n}\n\nexport interface WorkflowDef\n  extends Omit<OriginalWorkflowDef, \"tasks\" | \"version\" | \"inputParameters\"> {\n  inputParameters: string[];\n  version: number;\n  tasks: TaskDefTypes[];\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { EventHandler } from '../models/EventHandler';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class EventResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Get queue config by name\n   * @param queueType\n   * @param queueName\n   * @returns any OK\n   * @throws ApiError\n   */\n  public getQueueConfig(\n    queueType: string,\n    queueName: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/event/queue/config/{queueType}/{queueName}',\n      path: {\n        'queueType': queueType,\n        'queueName': queueName,\n      },\n    });\n  }\n\n  /**\n   * Create or update queue config by name\n   * @param queueType\n   * @param queueName\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public putQueueConfig(\n    queueType: string,\n    queueName: string,\n    requestBody: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/event/queue/config/{queueType}/{queueName}',\n      path: {\n        'queueType': queueType,\n        'queueName': queueName,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Delete queue config by name\n   * @param queueType\n   * @param queueName\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteQueueConfig(\n    queueType: string,\n    queueName: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/event/queue/config/{queueType}/{queueName}',\n      path: {\n        'queueType': queueType,\n        'queueName': queueName,\n      },\n    });\n  }\n\n  /**\n   * Get all the event handlers\n   * @returns EventHandler OK\n   * @throws ApiError\n   */\n  public getEventHandlers(): CancelablePromise<Array<EventHandler>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/event',\n    });\n  }\n\n  /**\n   * Update an existing event handler.\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public updateEventHandler(\n    requestBody: EventHandler,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/event',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Add a new event handler.\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public addEventHandler(\n    requestBody: EventHandler,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/event',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get all queue configs\n   * @returns any OK\n   * @throws ApiError\n   */\n  public getQueueNames(): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/event/queue/config',\n    });\n  }\n\n  /**\n   * Remove an event handler\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public removeEventHandlerStatus(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/event/{name}',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Get event handlers for a given event\n   * @param event\n   * @param activeOnly\n   * @returns EventHandler OK\n   * @throws ApiError\n   */\n  public getEventHandlersForEvent(\n    event: string,\n    activeOnly: boolean = true,\n  ): CancelablePromise<Array<EventHandler>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/event/{event}',\n      path: {\n        'event': event,\n      },\n      query: {\n        'activeOnly': activeOnly,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class HealthCheckResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * @returns any OK\n   * @throws ApiError\n   */\n  public doCheck(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/health',\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { TaskDef } from '../models/TaskDef';\nimport type { WorkflowDef } from '../models/WorkflowDef';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class MetadataResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Gets the task definition\n   * @param tasktype\n   * @param metadata\n   * @returns TaskDef OK\n   * @throws ApiError\n   */\n  public getTaskDef(\n    tasktype: string,\n    metadata: boolean = false,\n  ): CancelablePromise<TaskDef> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/metadata/taskdefs/{tasktype}',\n      path: {\n        'tasktype': tasktype,\n      },\n      query: {\n        'metadata': metadata,\n      },\n    });\n  }\n\n  /**\n   * Remove a task definition\n   * @param tasktype\n   * @returns any OK\n   * @throws ApiError\n   */\n  public unregisterTaskDef(\n    tasktype: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/metadata/taskdefs/{tasktype}',\n      path: {\n        'tasktype': tasktype,\n      },\n    });\n  }\n\n  /**\n   * Retrieves all workflow definition along with blueprint\n   * @param access\n   * @param metadata\n   * @param tagKey\n   * @param tagValue\n   * @returns WorkflowDef OK\n   * @throws ApiError\n   */\n  public getAllWorkflows(\n    access: string = 'READ',\n    metadata: boolean = false,\n    tagKey?: string,\n    tagValue?: string,\n  ): CancelablePromise<Array<WorkflowDef>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/metadata/workflow',\n      query: {\n        'access': access,\n        'metadata': metadata,\n        'tagKey': tagKey,\n        'tagValue': tagValue,\n      },\n    });\n  }\n\n  /**\n   * Create or update workflow definition(s)\n   * @param requestBody\n   * @param overwrite\n   * @returns any OK\n   * @throws ApiError\n   */\n  public update(\n    requestBody: Array<WorkflowDef>,\n    overwrite: boolean = true,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/metadata/workflow',\n      query: {\n        'overwrite': overwrite,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Create a new workflow definition\n   * @param requestBody\n   * @param overwrite\n   * @returns any OK\n   * @throws ApiError\n   */\n  public create(\n    requestBody: WorkflowDef,\n    overwrite: boolean = false,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/metadata/workflow',\n      query: {\n        'overwrite': overwrite,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Gets all task definition\n   * @param access\n   * @param metadata\n   * @param tagKey\n   * @param tagValue\n   * @returns TaskDef OK\n   * @throws ApiError\n   */\n  public getTaskDefs(\n    access: string = 'READ',\n    metadata: boolean = false,\n    tagKey?: string,\n    tagValue?: string,\n  ): CancelablePromise<Array<TaskDef>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/metadata/taskdefs',\n      query: {\n        'access': access,\n        'metadata': metadata,\n        'tagKey': tagKey,\n        'tagValue': tagValue,\n      },\n    });\n  }\n\n  /**\n   * Update an existing task\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public updateTaskDef(\n    requestBody: TaskDef,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/metadata/taskdefs',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Create or update task definition(s)\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public registerTaskDef(\n    requestBody: Array<TaskDef>,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/metadata/taskdefs',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Removes workflow definition. It does not remove workflows associated with the definition.\n   * @param name\n   * @param version\n   * @returns any OK\n   * @throws ApiError\n   */\n  public unregisterWorkflowDef(\n    name: string,\n    version: number,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/metadata/workflow/{name}/{version}',\n      path: {\n        'name': name,\n        'version': version,\n      },\n    });\n  }\n\n  /**\n   * Retrieves workflow definition along with blueprint\n   * @param name\n   * @param version\n   * @param metadata\n   * @returns WorkflowDef OK\n   * @throws ApiError\n   */\n  public get(\n    name: string,\n    version?: number,\n    metadata: boolean = false,\n  ): CancelablePromise<WorkflowDef> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/metadata/workflow/{name}',\n      path: {\n        'name': name,\n      },\n      query: {\n        'version': version,\n        'metadata': metadata,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { SaveScheduleRequest } from '../models/SaveScheduleRequest';\nimport type { SearchResultWorkflowScheduleExecutionModel } from '../models/SearchResultWorkflowScheduleExecutionModel';\nimport type { WorkflowSchedule } from '../models/WorkflowSchedule';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class SchedulerResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Get an existing workflow schedule by name\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public getSchedule(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/schedules/{name}',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Deletes an existing workflow schedule by name\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteSchedule(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/scheduler/schedules/{name}',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Get list of the next x (default 3, max 5) execution times for a scheduler\n   * @param cronExpression\n   * @param scheduleStartTime\n   * @param scheduleEndTime\n   * @param limit\n   * @returns number OK\n   * @throws ApiError\n   */\n  public getNextFewSchedules(\n    cronExpression: string,\n    scheduleStartTime?: number,\n    scheduleEndTime?: number,\n    limit: number = 3,\n  ): CancelablePromise<Array<number>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/nextFewSchedules',\n      query: {\n        'cronExpression': cronExpression,\n        'scheduleStartTime': scheduleStartTime,\n        'scheduleEndTime': scheduleEndTime,\n        'limit': limit,\n      },\n    });\n  }\n\n  /**\n   * Pauses an existing schedule by name\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public pauseSchedule(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/schedules/{name}/pause',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Pause all scheduling in a single conductor server instance (for debugging only)\n   * @returns any OK\n   * @throws ApiError\n   */\n  public pauseAllSchedules(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/admin/pause',\n    });\n  }\n\n  /**\n   * Resume a paused schedule by name\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public resumeSchedule(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/schedules/{name}/resume',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Requeue all execution records\n   * @returns any OK\n   * @throws ApiError\n   */\n  public requeueAllExecutionRecords(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/admin/requeue',\n    });\n  }\n\n  /**\n   * Resume all scheduling\n   * @returns any OK\n   * @throws ApiError\n   */\n  public resumeAllSchedules(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/admin/resume',\n    });\n  }\n\n  /**\n   * Get all existing workflow schedules and optionally filter by workflow name\n   * @param workflowName\n   * @returns WorkflowSchedule OK\n   * @throws ApiError\n   */\n  public getAllSchedules(\n    workflowName?: string,\n  ): CancelablePromise<Array<WorkflowSchedule>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/schedules',\n      query: {\n        'workflowName': workflowName,\n      },\n    });\n  }\n\n  /**\n   * Create or update a schedule for a specified workflow with a corresponding start workflow request\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public saveSchedule(\n    requestBody: SaveScheduleRequest,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/scheduler/schedules',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Test timeout - do not use in production\n   * @returns any OK\n   * @throws ApiError\n   */\n  public testTimeout(): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/test/timeout',\n    });\n  }\n\n  /**\n   * Search for workflows based on payload and other parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflowScheduleExecutionModel OK\n   * @throws ApiError\n   */\n  public searchV21(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultWorkflowScheduleExecutionModel> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/scheduler/search/executions',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ExternalStorageLocation } from '../models/ExternalStorageLocation';\nimport type { PollData } from '../models/PollData';\nimport type { SearchResultTask } from '../models/SearchResultTask';\nimport type { SearchResultTaskSummary } from '../models/SearchResultTaskSummary';\nimport type { Task } from '../models/Task';\nimport type { TaskExecLog } from '../models/TaskExecLog';\nimport type { TaskResult } from '../models/TaskResult';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class TaskResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Poll for a task of a certain type\n   * @param tasktype\n   * @param workerid\n   * @param domain\n   * @returns Task OK\n   * @throws ApiError\n   */\n  public poll(\n    tasktype: string,\n    workerid?: string,\n    domain?: string,\n  ): CancelablePromise<Task> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/poll/{tasktype}',\n      path: {\n        'tasktype': tasktype,\n      },\n      query: {\n        'workerid': workerid,\n        'domain': domain,\n      },\n    });\n  }\n\n  /**\n   * Get the details about each queue\n   * @returns number OK\n   * @throws ApiError\n   */\n  public allVerbose(): CancelablePromise<Record<string, Record<string, Record<string, number>>>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/queue/all/verbose',\n    });\n  }\n\n  /**\n   * Update a task By Ref Name\n   * @param workflowId\n   * @param taskRefName\n   * @param status\n   * @param requestBody\n   * @returns string OK\n   * @throws ApiError\n   */\n  public updateTask(\n    workflowId: string,\n    taskRefName: string,\n    status: 'IN_PROGRESS' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED',\n    requestBody: Record<string, any>,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/tasks/{workflowId}/{taskRefName}/{status}',\n      path: {\n        'workflowId': workflowId,\n        'taskRefName': taskRefName,\n        'status': status,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get task by Id\n   * @param taskId\n   * @returns Task OK\n   * @throws ApiError\n   */\n  public getTask(\n    taskId: string,\n  ): CancelablePromise<Task> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/{taskId}',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n  /**\n   * Get the details about each queue\n   * @returns number OK\n   * @throws ApiError\n   */\n  public all(): CancelablePromise<Record<string, number>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/queue/all',\n    });\n  }\n\n  /**\n   * Requeue pending tasks\n   * @param taskType\n   * @returns string OK\n   * @throws ApiError\n   */\n  public requeuePendingTask(\n    taskType: string,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/tasks/queue/requeue/{taskType}',\n      path: {\n        'taskType': taskType,\n      },\n    });\n  }\n\n  /**\n   * Search for tasks based in payload and other parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultTaskSummary OK\n   * @throws ApiError\n   */\n  public search(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultTaskSummary> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/search',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n  /**\n   * Search for tasks based in payload and other parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultTask OK\n   * @throws ApiError\n   */\n  public searchV22(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultTask> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/search-v2',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n  /**\n   * Get the last poll data for a given task type\n   * @param taskType\n   * @returns PollData OK\n   * @throws ApiError\n   */\n  public getPollData(\n    taskType: string,\n  ): CancelablePromise<Array<PollData>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/queue/polldata',\n      query: {\n        'taskType': taskType,\n      },\n    });\n  }\n\n  /**\n   * Get Task Execution Logs\n   * @param taskId\n   * @returns TaskExecLog OK\n   * @throws ApiError\n   */\n  public getTaskLogs(\n    taskId: string,\n  ): CancelablePromise<Array<TaskExecLog>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/{taskId}/log',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n  /**\n   * Log Task Execution Details\n   * @param taskId\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public log(\n    taskId: string,\n    requestBody: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/tasks/{taskId}/log',\n      path: {\n        'taskId': taskId,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get the last poll data for all task types\n   * @returns PollData OK\n   * @throws ApiError\n   */\n  public getAllPollData(): CancelablePromise<Array<PollData>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/queue/polldata/all',\n    });\n  }\n\n  /**\n   * Batch poll for a task of a certain type\n   * @param tasktype\n   * @param workerid\n   * @param domain\n   * @param count\n   * @param timeout\n   * @returns Task OK\n   * @throws ApiError\n   */\n  public batchPoll(\n    tasktype: string,\n    workerid?: string,\n    domain?: string,\n    count: number = 1,\n    timeout: number = 100,\n  ): CancelablePromise<Array<Task>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/poll/batch/{tasktype}',\n      path: {\n        'tasktype': tasktype,\n      },\n      query: {\n        'workerid': workerid,\n        'domain': domain,\n        'count': count,\n        'timeout': timeout,\n      },\n    });\n  }\n\n  /**\n   * Update a task\n   * @param requestBody\n   * @returns string OK\n   * @throws ApiError\n   */\n  public updateTask1(\n    requestBody: TaskResult,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/tasks',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get Task type queue sizes\n   * @param taskType\n   * @returns number OK\n   * @throws ApiError\n   */\n  public size1(\n    taskType?: Array<string>,\n  ): CancelablePromise<Record<string, number>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/queue/sizes',\n      query: {\n        'taskType': taskType,\n      },\n    });\n  }\n\n  /**\n   * Get the external uri where the task payload is to be stored\n   * @param path\n   * @param operation\n   * @param payloadType\n   * @returns ExternalStorageLocation OK\n   * @throws ApiError\n   */\n  public getExternalStorageLocation1(\n    path: string,\n    operation: string,\n    payloadType: string,\n  ): CancelablePromise<ExternalStorageLocation> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/tasks/externalstoragelocation',\n      query: {\n        'path': path,\n        'operation': operation,\n        'payloadType': payloadType,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { GenerateTokenRequest } from '../models/GenerateTokenRequest';\nimport type { Response } from '../models/Response';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class TokenResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Generate JWT with the given access key\n   * @param requestBody\n   * @returns Response OK\n   * @throws ApiError\n   */\n  public generateToken(\n    requestBody: GenerateTokenRequest,\n  ): CancelablePromise<Response> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/token',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get the user info from the token\n   * @returns any OK\n   * @throws ApiError\n   */\n  public getUserInfo(): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/token/userInfo',\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { BulkResponse } from '../models/BulkResponse';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class WorkflowBulkResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Retry the last failed task for each workflow from the list\n   * @param requestBody\n   * @returns BulkResponse OK\n   * @throws ApiError\n   */\n  public retry(\n    requestBody: Array<string>,\n  ): CancelablePromise<BulkResponse> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/bulk/retry',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Restart the list of completed workflow\n   * @param requestBody\n   * @param useLatestDefinitions\n   * @returns BulkResponse OK\n   * @throws ApiError\n   */\n  public restart(\n    requestBody: Array<string>,\n    useLatestDefinitions: boolean = false,\n  ): CancelablePromise<BulkResponse> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/bulk/restart',\n      query: {\n        'useLatestDefinitions': useLatestDefinitions,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Terminate workflows execution\n   * @param requestBody\n   * @param reason\n   * @returns BulkResponse OK\n   * @throws ApiError\n   */\n  public terminate(\n    requestBody: Array<string>,\n    reason?: string,\n  ): CancelablePromise<BulkResponse> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/bulk/terminate',\n      query: {\n        'reason': reason,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Resume the list of workflows\n   * @param requestBody\n   * @returns BulkResponse OK\n   * @throws ApiError\n   */\n  public resumeWorkflow(\n    requestBody: Array<string>,\n  ): CancelablePromise<BulkResponse> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/bulk/resume',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Pause the list of workflows\n   * @param requestBody\n   * @returns BulkResponse OK\n   * @throws ApiError\n   */\n  public pauseWorkflow1(\n    requestBody: Array<string>,\n  ): CancelablePromise<BulkResponse> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/bulk/pause',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ExternalStorageLocation } from '../models/ExternalStorageLocation';\nimport type { RerunWorkflowRequest } from '../models/RerunWorkflowRequest';\nimport type { ScrollableSearchResultWorkflowSummary } from '../models/ScrollableSearchResultWorkflowSummary';\nimport type { SearchResultWorkflow } from '../models/SearchResultWorkflow';\nimport type { SearchResultWorkflowSummary } from '../models/SearchResultWorkflowSummary';\nimport type { SkipTaskRequest } from '../models/SkipTaskRequest';\nimport type { StartWorkflowRequest } from '../models/StartWorkflowRequest';\nimport type { Workflow } from '../models/Workflow';\nimport type { WorkflowRun } from '../models/WorkflowRun';\nimport type { WorkflowStatus } from '../models/WorkflowStatus';\nimport type { WorkflowTestRequest } from '../models/WorkflowTestRequest';\n\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class WorkflowResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) { }\n\n  /**\n   * Retrieve all the running workflows\n   * @param name\n   * @param version\n   * @param startTime\n   * @param endTime\n   * @returns string OK\n   * @throws ApiError\n   */\n  public getRunningWorkflow(\n    name: string,\n    version: number = 1,\n    startTime?: number,\n    endTime?: number,\n  ): CancelablePromise<Array<string>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/running/{name}',\n      path: {\n        'name': name,\n      },\n      query: {\n        'version': version,\n        'startTime': startTime,\n        'endTime': endTime,\n      },\n    });\n  }\n\n  /**\n   * Execute a workflow synchronously\n   * @param body \n   * @param name \n   * @param version \n   * @param requestId \n   * @param waitUntilTaskRef \n   * @param callback \n   * @returns workflowRun\n   * @throws ApiError\n   */\n  public executeWorkflow(\n    body: StartWorkflowRequest,\n    name: string,\n    version: number,\n    requestId: string,\n    waitUntilTaskRef: string,\n  ): CancelablePromise<WorkflowRun> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/execute/{name}/{version}',\n      path: {\n        'name': name,\n        'version': version,\n      },\n      query: {\n        'requestId': requestId,\n        'waitUntilTaskRef': waitUntilTaskRef,\n      },\n      body: body,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain\n   * @param requestBody\n   * @returns string OK\n   * @throws ApiError\n   */\n  public startWorkflow(\n    requestBody: StartWorkflowRequest,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Starts the decision task for a workflow\n   * @param workflowId\n   * @returns any OK\n   * @throws ApiError\n   */\n  public decide(\n    workflowId: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/decide/{workflowId}',\n      path: {\n        'workflowId': workflowId,\n      },\n    });\n  }\n\n  /**\n   * Reruns the workflow from a specific task\n   * @param workflowId\n   * @param requestBody\n   * @returns string OK\n   * @throws ApiError\n   */\n  public rerun(\n    workflowId: string,\n    requestBody: RerunWorkflowRequest,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{workflowId}/rerun',\n      path: {\n        'workflowId': workflowId,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Search for workflows based on payload and other parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflow OK\n   * @throws ApiError\n   */\n  public searchV21(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultWorkflow> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/search-v2',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n  /**\n   * Pauses the workflow\n   * @param workflowId\n   * @returns any OK\n   * @throws ApiError\n   */\n  public pauseWorkflow(\n    workflowId: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/{workflowId}/pause',\n      path: {\n        'workflowId': workflowId,\n      },\n    });\n  }\n\n  /**\n   * Skips a given task from a current running workflow\n   * @param workflowId\n   * @param taskReferenceName\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public skipTaskFromWorkflow(\n    workflowId: string,\n    taskReferenceName: string,\n    requestBody?: SkipTaskRequest,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/{workflowId}/skiptask/{taskReferenceName}',\n      path: {\n        'workflowId': workflowId,\n        'taskReferenceName': taskReferenceName,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Lists workflows for the given correlation id list\n   * @param name\n   * @param requestBody\n   * @param includeClosed\n   * @param includeTasks\n   * @returns Workflow OK\n   * @throws ApiError\n   */\n  public getWorkflows(\n    name: string,\n    requestBody: Array<string>,\n    includeClosed: boolean = false,\n    includeTasks: boolean = false,\n  ): CancelablePromise<Record<string, Array<Workflow>>> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{name}/correlated',\n      path: {\n        'name': name,\n      },\n      query: {\n        'includeClosed': includeClosed,\n        'includeTasks': includeTasks,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Gets the workflow by workflow id\n   * @param workflowId\n   * @param includeOutput\n   * @param includeVariables\n   * @returns WorkflowStatus OK\n   * @throws ApiError\n   */\n  public getWorkflowStatusSummary(\n    workflowId: string,\n    includeOutput: boolean = false,\n    includeVariables: boolean = false,\n  ): CancelablePromise<WorkflowStatus> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/{workflowId}/status',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'includeOutput': includeOutput,\n        'includeVariables': includeVariables,\n      },\n    });\n  }\n\n  /**\n   * Lists workflows for the given correlation id\n   * @param name\n   * @param correlationId\n   * @param includeClosed\n   * @param includeTasks\n   * @returns Workflow OK\n   * @throws ApiError\n   */\n  public getWorkflows1(\n    name: string,\n    correlationId: string,\n    includeClosed: boolean = false,\n    includeTasks: boolean = false,\n  ): CancelablePromise<Array<Workflow>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/{name}/correlated/{correlationId}',\n      path: {\n        'name': name,\n        'correlationId': correlationId,\n      },\n      query: {\n        'includeClosed': includeClosed,\n        'includeTasks': includeTasks,\n      },\n    });\n  }\n\n  /**\n   * Retries the last failed task\n   * @param workflowId\n   * @param resumeSubworkflowTasks\n   * @returns void\n   * @throws ApiError\n   */\n  public retry1(\n    workflowId: string,\n    resumeSubworkflowTasks: boolean = false,\n  ): CancelablePromise<void> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{workflowId}/retry',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'resumeSubworkflowTasks': resumeSubworkflowTasks,\n      },\n    });\n  }\n\n  /**\n   * Gets the workflow by workflow id\n   * @param workflowId\n   * @param includeTasks\n   * @returns Workflow OK\n   * @throws ApiError\n   */\n  public getExecutionStatus(\n    workflowId: string,\n    includeTasks: boolean = true,\n  ): CancelablePromise<Workflow> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/{workflowId}',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'includeTasks': includeTasks,\n      },\n    });\n  }\n\n  /**\n   * Terminate workflow execution\n   * @param workflowId\n   * @param reason\n   * @returns any OK\n   * @throws ApiError\n   */\n  public terminate1(\n    workflowId: string,\n    reason?: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/workflow/{workflowId}',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'reason': reason,\n      },\n    });\n  }\n\n  /**\n   * Resumes the workflow\n   * @param workflowId\n   * @returns any OK\n   * @throws ApiError\n   */\n  public resumeWorkflow(\n    workflowId: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'PUT',\n      url: '/workflow/{workflowId}/resume',\n      path: {\n        'workflowId': workflowId,\n      },\n    });\n  }\n\n  /**\n   * Removes the workflow from the system\n   * @param workflowId\n   * @param archiveWorkflow\n   * @returns any OK\n   * @throws ApiError\n   */\n  public delete(\n    workflowId: string,\n    archiveWorkflow: boolean = true,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/workflow/{workflowId}/remove',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'archiveWorkflow': archiveWorkflow,\n      },\n    });\n  }\n\n  /**\n   * Search for workflows based on task parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflowSummary OK\n   * @throws ApiError\n   */\n  public searchWorkflowsByTasks(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultWorkflowSummary> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/search-by-tasks',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n  /**\n   * Get the uri and path of the external storage where the workflow payload is to be stored\n   * @param path\n   * @param operation\n   * @param payloadType\n   * @returns ExternalStorageLocation OK\n   * @throws ApiError\n   */\n  public getExternalStorageLocation(\n    path: string,\n    operation: string,\n    payloadType: string,\n  ): CancelablePromise<ExternalStorageLocation> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/externalstoragelocation',\n      query: {\n        'path': path,\n        'operation': operation,\n        'payloadType': payloadType,\n      },\n    });\n  }\n\n  /**\n   * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking\n   * @param name\n   * @param requestBody\n   * @param version\n   * @param correlationId\n   * @param priority\n   * @returns string OK\n   * @throws ApiError\n   */\n  public startWorkflow1(\n    name: string,\n    requestBody: Record<string, any>,\n    version?: number,\n    correlationId?: string,\n    priority?: number,\n  ): CancelablePromise<string> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{name}',\n      path: {\n        'name': name,\n      },\n      query: {\n        'version': version,\n        'correlationId': correlationId,\n        'priority': priority,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Restarts a completed workflow\n   * @param workflowId\n   * @param useLatestDefinitions\n   * @returns void\n   * @throws ApiError\n   */\n  public restart1(\n    workflowId: string,\n    useLatestDefinitions: boolean = false,\n  ): CancelablePromise<void> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{workflowId}/restart',\n      path: {\n        'workflowId': workflowId,\n      },\n      query: {\n        'useLatestDefinitions': useLatestDefinitions,\n      },\n    });\n  }\n\n  /**\n   * Search for workflows based on payload and other parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.\n   * @param queryId\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @param skipCache\n   * @returns ScrollableSearchResultWorkflowSummary OK\n   * @throws ApiError\n   */\n  public search1(\n    queryId?: string,\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n    skipCache: boolean = false,\n  ): CancelablePromise<ScrollableSearchResultWorkflowSummary> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/search',\n      query: {\n        'queryId': queryId,\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n        'skipCache': skipCache,\n      },\n    });\n  }\n\n  /**\n   * Search for workflows based on task parameters\n   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflow OK\n   * @throws ApiError\n   */\n  public searchWorkflowsByTasksV2(\n    start?: number,\n    size: number = 100,\n    sort?: string,\n    freeText: string = '*',\n    query?: string,\n  ): CancelablePromise<SearchResultWorkflow> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/workflow/search-by-tasks-v2',\n      query: {\n        'start': start,\n        'size': size,\n        'sort': sort,\n        'freeText': freeText,\n        'query': query,\n      },\n    });\n  }\n\n  /**\n   * Resets callback times of all non-terminal SIMPLE tasks to 0\n   * @param workflowId\n   * @returns void\n   * @throws ApiError\n   */\n  public resetWorkflow(\n    workflowId: string,\n  ): CancelablePromise<void> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/{workflowId}/resetcallbacks',\n      path: {\n        'workflowId': workflowId,\n      },\n    });\n  }\n\n  /**\n   * Test workflow execution using mock data\n   * @param requestBody\n   * @returns Workflow OK\n   * @throws ApiError\n   */\n  public testWorkflow(\n    requestBody: WorkflowTestRequest\n  ): CancelablePromise<Workflow> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/workflow/test',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\n\nexport class ApiError extends Error {\n  public readonly url: string;\n  public readonly status: number;\n  public readonly statusText: string;\n  public readonly body: any;\n  public readonly request: ApiRequestOptions;\n\n  constructor(request: ApiRequestOptions, response: ApiResult, message: string) {\n    super(message);\n\n    this.name = 'ApiError';\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.body = response.body;\n    this.request = request;\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nexport class CancelError extends Error {\n\n  constructor(message: string) {\n    super(message);\n    this.name = 'CancelError';\n  }\n\n  public get isCancelled(): boolean {\n    return true;\n  }\n}\n\nexport interface OnCancel {\n  readonly isResolved: boolean;\n  readonly isRejected: boolean;\n  readonly isCancelled: boolean;\n\n  (cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]!: string;\n\n  private _isResolved: boolean;\n  private _isRejected: boolean;\n  private _isCancelled: boolean;\n  private readonly _cancelHandlers: (() => void)[];\n  private readonly _promise: Promise<T>;\n  private _resolve?: (value: T | PromiseLike<T>) => void;\n  private _reject?: (reason?: any) => void;\n\n  constructor(\n    executor: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancel\n    ) => void\n  ) {\n    this._isResolved = false;\n    this._isRejected = false;\n    this._isCancelled = false;\n    this._cancelHandlers = [];\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n\n      const onResolve = (value: T | PromiseLike<T>): void => {\n        if (this._isResolved || this._isRejected || this._isCancelled) {\n          return;\n        }\n        this._isResolved = true;\n        this._resolve?.(value);\n      };\n\n      const onReject = (reason?: any): void => {\n        if (this._isResolved || this._isRejected || this._isCancelled) {\n          return;\n        }\n        this._isRejected = true;\n        this._reject?.(reason);\n      };\n\n      const onCancel = (cancelHandler: () => void): void => {\n        if (this._isResolved || this._isRejected || this._isCancelled) {\n          return;\n        }\n        this._cancelHandlers.push(cancelHandler);\n      };\n\n      Object.defineProperty(onCancel, 'isResolved', {\n        get: (): boolean => this._isResolved,\n      });\n\n      Object.defineProperty(onCancel, 'isRejected', {\n        get: (): boolean => this._isRejected,\n      });\n\n      Object.defineProperty(onCancel, 'isCancelled', {\n        get: (): boolean => this._isCancelled,\n      });\n\n      return executor(onResolve, onReject, onCancel as OnCancel);\n    });\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  public catch<TResult = never>(\n    onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null\n  ): Promise<T | TResult> {\n    return this._promise.catch(onRejected);\n  }\n\n  public finally(onFinally?: (() => void) | null): Promise<T> {\n    return this._promise.finally(onFinally);\n  }\n\n  public cancel(): void {\n    if (this._isResolved || this._isRejected || this._isCancelled) {\n      return;\n    }\n    this._isCancelled = true;\n    if (this._cancelHandlers.length) {\n      try {\n        for (const cancelHandler of this._cancelHandlers) {\n          cancelHandler();\n        }\n      } catch (error) {\n        console.warn('Cancellation threw an error', error);\n        return;\n      }\n    }\n    this._cancelHandlers.length = 0;\n    this._reject?.(new CancelError('Request aborted'));\n  }\n\n  public get isCancelled(): boolean {\n    return this._isCancelled;\n  }\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nimport { ApiError } from \"./ApiError\";\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { ApiResult } from \"./ApiResult\";\nimport { CancelablePromise } from \"./CancelablePromise\";\nimport type { OnCancel } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\n\nconst isDefined = <T>(\n  value: T | null | undefined\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\nconst isString = (value: any): value is string => {\n  return typeof value === \"string\";\n};\n\nconst isStringWithValue = (value: any): value is string => {\n  return isString(value) && value !== \"\";\n};\n\nconst isBlob = (value: any): value is Blob => {\n  return (\n    typeof value === \"object\" &&\n    typeof value.type === \"string\" &&\n    typeof value.stream === \"function\" &&\n    typeof value.arrayBuffer === \"function\" &&\n    typeof value.constructor === \"function\" &&\n    typeof value.constructor.name === \"string\" &&\n    /^(Blob|File)$/.test(value.constructor.name) &&\n    /^(Blob|File)$/.test(value[Symbol.toStringTag])\n  );\n};\n\nconst isFormData = (value: any): value is FormData => {\n  return value instanceof FormData;\n};\n\nconst base64 = (str: string): string => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString(\"base64\");\n  }\n};\n\nconst getQueryString = (params: Record<string, any>): string => {\n  const qs: string[] = [];\n\n  const append = (key: string, value: any) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  const process = (key: string, value: any) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => {\n          process(key, v);\n        });\n      } else if (typeof value === \"object\") {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join(\"&\")}`;\n  }\n\n  return \"\";\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n\n  const path = options.url\n    .replace(\"{api-version}\", config.VERSION)\n    .replace(/{(.*?)}/g, (substring: string, group: string) => {\n      if (options.path?.hasOwnProperty(group)) {\n        return encoder(String(options.path[group]));\n      }\n      return substring;\n    });\n\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\n\nconst getFormData = (options: ApiRequestOptions): FormData | undefined => {\n  if (options.formData) {\n    const formData = new FormData();\n\n    const process = (key: string, value: any) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData)\n      .filter(([_, value]) => isDefined(value))\n      .forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((v) => process(key, v));\n        } else {\n          process(key, value);\n        }\n      });\n\n    return formData;\n  }\n  return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nconst resolve = async <T>(\n  options: ApiRequestOptions,\n  resolver?: T | Resolver<T>\n): Promise<T | undefined> => {\n  if (typeof resolver === \"function\") {\n    return (resolver as Resolver<T>)(options);\n  }\n  return resolver;\n};\n\nconst getHeaders = async (\n  config: OpenAPIConfig,\n  options: ApiRequestOptions\n): Promise<Headers> => {\n  const token = await resolve(options, config.TOKEN);\n  const username = await resolve(options, config.USERNAME);\n  const password = await resolve(options, config.PASSWORD);\n  const additionalHeaders = await resolve(options, config.HEADERS);\n\n  const headers = Object.entries({\n    Accept: \"application/json\",\n    ...additionalHeaders,\n    ...options.headers,\n  })\n    .filter(([_, value]) => isDefined(value))\n    .reduce(\n      (headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n      }),\n      {} as Record<string, string>\n    );\n\n  if (isStringWithValue(token)) {\n    headers[\"X-AUTHORIZATION\"] = token;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers[\"Authorization\"] = `Basic ${credentials}`;\n  }\n\n  if (options.body) {\n    if (options.mediaType) {\n      headers[\"Content-Type\"] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers[\"Content-Type\"] = \"application/octet-stream\";\n    } else if (isString(options.body)) {\n      headers[\"Content-Type\"] = \"text/plain\";\n    } else if (!isFormData(options.body)) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n  }\n\n  return new Headers(headers);\n};\n\nconst getRequestBody = (options: ApiRequestOptions): any => {\n  if (options.body) {\n    if (options.mediaType?.includes(\"/json\")) {\n      return JSON.stringify(options.body);\n    } else if (\n      isString(options.body) ||\n      isBlob(options.body) ||\n      isFormData(options.body)\n    ) {\n      return options.body as any;\n    } else {\n      return JSON.stringify(options.body);\n    }\n  }\n  return undefined;\n};\n\nexport const sendRequest = async (\n  options: ApiRequestOptions,\n  url: string,\n  body: any,\n  formData: FormData | undefined,\n  headers: Headers,\n  onCancel: OnCancel\n): Promise<Response> => {\n  const controller = new AbortController();\n\n  const request: RequestInit = {\n    headers,\n    method: options.method,\n    body: body ?? formData,\n    signal: controller.signal as AbortSignal,\n  };\n\n  onCancel(() => controller.abort());\n\n  return await fetch(url, request);\n};\n\nconst getResponseHeader = (\n  response: Response,\n  responseHeader?: string\n): string | undefined => {\n  if (responseHeader) {\n    const content = response.headers.get(responseHeader);\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return undefined;\n};\n\nconst getResponseBody = async (response: Response): Promise<any> => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get(\"Content-Type\");\n      if (contentType) {\n        const isJSON = contentType.toLowerCase().startsWith(\"application/json\");\n        if (isJSON) {\n          return await response.json();\n        } else {\n          return await response.text();\n        }\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return undefined;\n};\n\nconst catchErrorCodes = (\n  options: ApiRequestOptions,\n  result: ApiResult\n): void => {\n  const errors: Record<number, string> = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    500: \"Internal Server Error\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    ...options.errors,\n  };\n\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n\n  if (!result.ok) {\n    throw new ApiError(options, result, \"Generic Error\");\n  }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions\n): CancelablePromise<T> => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    try {\n      const url = getUrl(config, options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options);\n\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(\n          options,\n          url,\n          body,\n          formData,\n          headers,\n          onCancel\n        );\n        const responseBody = await getResponseBody(response);\n        const responseHeader = getResponseHeader(\n          response,\n          options.responseHeader\n        );\n\n        const result: ApiResult = {\n          url,\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader ?? responseBody,\n        };\n\n        catchErrorCodes(options, result);\n\n        resolve(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { HumanTaskAssignment } from '../models/HumanTaskAssignment';\nimport type { HumanTaskEntry } from '../models/HumanTaskEntry';\nimport type { HumanTaskSearch } from '../models/HumanTaskSearch';\nimport type { HumanTaskSearchResult } from '../models/HumanTaskSearchResult';\nimport type { HumanTaskTemplate } from '../models/HumanTaskTemplate';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class HumanTaskService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * If the workflow is disconnected from tasks, this API can be used to clean up (in bulk)\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteTaskFromHumanTaskRecords(\n    requestBody: Array<string>,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/human/tasks/delete',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * If the workflow is disconnected from tasks, this API can be used to clean up\n   * @param taskId\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteTaskFromHumanTaskRecords1(\n    taskId: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/human/tasks/delete/{taskId}',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n  /**\n   * Search human tasks\n   * @param requestBody\n   * @returns HumanTaskSearchResult OK\n   * @throws ApiError\n   */\n  public search(\n    requestBody: HumanTaskSearch,\n  ): CancelablePromise<HumanTaskSearchResult> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/search',\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Update task output, optionally complete\n   * @param workflowId\n   * @param taskRefName\n   * @param requestBody\n   * @param complete\n   * @param iteration Populate this value if your task is in a loop and you want to update a specific iteration. If its not in a loop OR if you want to just update the latest iteration, leave this as empty\n   * @returns any OK\n   * @throws ApiError\n   */\n  public updateTaskOutputByRef(\n    workflowId: string,\n    taskRefName: string,\n    requestBody: Record<string, any>,\n    complete: boolean = false,\n    iteration?: Array<number>,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/update/taskRef',\n      query: {\n        'workflowId': workflowId,\n        'taskRefName': taskRefName,\n        'complete': complete,\n        'iteration': iteration,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Get a task\n   * @param taskId\n   * @returns HumanTaskEntry OK\n   * @throws ApiError\n   */\n  public getTask1(\n    taskId: string,\n  ): CancelablePromise<HumanTaskEntry> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/human/tasks/{taskId}',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n  /**\n   * Claim a task by authenticated Conductor user\n   * @param taskId\n   * @param overrideAssignment\n   * @returns any OK\n   * @throws ApiError\n   */\n  public claimTask(\n    taskId: string,\n    overrideAssignment: boolean = false,\n    withTemplate: boolean = false,\n  ): CancelablePromise<HumanTaskEntry> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/claim',\n      path: {\n        'taskId': taskId,\n      },\n      query: {\n        'overrideAssignment': overrideAssignment,\n        'withTemplate':withTemplate,\n      },\n    });\n  }\n\n  /**\n   * Claim a task to an external user\n   * @param taskId\n   * @param userId\n   * @param overrideAssignment\n   * @returns any OK\n   * @throws ApiError\n   */\n  public assignAndClaim(\n    taskId: string,\n    userId: string,\n    overrideAssignment: boolean = false,\n    withTemplate: boolean = false,\n  ): CancelablePromise<HumanTaskEntry> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/externalUser/{userId}',\n      path: {\n        'taskId': taskId,\n        'userId': userId,\n      },\n      query: {\n        'overrideAssignment': overrideAssignment,\n        'withTemplate':withTemplate,\n      },\n    });\n  }\n\n  /**\n   * Release a task without completing it\n   * @param taskId\n   * @param requestBody\n   * @returns any OK\n   * @throws ApiError\n   */\n  public reassignTask(\n    taskId: string,\n    requestBody: Array<HumanTaskAssignment>,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/reassign',\n      path: {\n        'taskId': taskId,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Release a task without completing it\n   * @param taskId\n   * @returns any OK\n   * @throws ApiError\n   */\n  public releaseTask(\n    taskId: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/release',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n  /**\n   * If a task is assigned to a user, this API can be used to skip that assignment and move to the next assignee\n   * @param taskId\n   * @param reason\n   * @returns any OK\n   * @throws ApiError\n   */\n  public skipTask(\n    taskId: string,\n    reason?: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/skip',\n      path: {\n        'taskId': taskId,\n      },\n      query: {\n        'reason': reason,\n      },\n    });\n  }\n\n  /**\n   * Update task output, optionally complete\n   * @param taskId\n   * @param requestBody\n   * @param complete\n   * @returns any OK\n   * @throws ApiError\n   */\n  public updateTaskOutput(\n    taskId: string,\n    requestBody: Record<string, any>,\n    complete: boolean = false,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/tasks/{taskId}/update',\n      path: {\n        'taskId': taskId,\n      },\n      query: {\n        'complete': complete,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * List all user form templates or get templates by name, or a template by name and version\n   * @param name\n   * @param version\n   * @returns HumanTaskTemplate OK\n   * @throws ApiError\n   */\n  public getAllTemplates(\n    name?: string,\n    version?: number,\n  ): CancelablePromise<Array<HumanTaskTemplate>> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/human/template',\n      query: {\n        'name': name,\n        'version': version,\n      },\n    });\n  }\n\n  /**\n   * Save user form template\n   * @param requestBody\n   * @param newVersion\n   * @returns HumanTaskTemplate OK\n   * @throws ApiError\n   */\n  public saveTemplate(\n    requestBody: HumanTaskTemplate,\n    newVersion: boolean = false,\n  ): CancelablePromise<HumanTaskTemplate> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/template',\n      query: {\n        'newVersion': newVersion,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Save user form template\n   * @param requestBody\n   * @param newVersion\n   * @returns HumanTaskTemplate OK\n   * @throws ApiError\n   */\n  public saveTemplates(\n    requestBody: Array<HumanTaskTemplate>,\n    newVersion: boolean = false,\n  ): CancelablePromise<Array<HumanTaskTemplate>> {\n    return this.httpRequest.request({\n      method: 'POST',\n      url: '/human/template/bulk',\n      query: {\n        'newVersion': newVersion,\n      },\n      body: requestBody,\n      mediaType: 'application/json',\n    });\n  }\n\n  /**\n   * Delete all versions of user form template by name\n   * @param name\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteTemplateByName(\n    name: string,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/human/template/{name}',\n      path: {\n        'name': name,\n      },\n    });\n  }\n\n  /**\n   * Delete a version of form template by name\n   * @param name\n   * @param version\n   * @returns any OK\n   * @throws ApiError\n   */\n  public deleteTemplatesByNameAndVersion(\n    name: string,\n    version: number,\n  ): CancelablePromise<any> {\n    return this.httpRequest.request({\n      method: 'DELETE',\n      url: '/human/template/{name}/{version}',\n      path: {\n        'name': name,\n        'version': version,\n      },\n    });\n  }\n\n  /**\n   * Get user form template by name and version\n   * @param name\n   * @param version\n   * @returns HumanTaskTemplate OK\n   * @throws ApiError\n   */\n  public getTemplateByNameAndVersion(\n    name: string,\n    version: number,\n  ): CancelablePromise<HumanTaskTemplate> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/human/template/{name}/{version}',\n      path: {\n        'name': name,\n        'version': version,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { Task } from '../models/Task';\n\nimport type { CancelablePromise } from '../core/CancelablePromise';\nimport type { BaseHttpRequest } from '../core/BaseHttpRequest';\n\nexport class HumanTaskResourceService {\n\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Get Conductor task by id (for human tasks only)\n   * @param taskId\n   * @returns Task OK\n   * @throws ApiError\n   */\n  public getConductorTaskById(\n    taskId: string,\n  ): CancelablePromise<Task> {\n    return this.httpRequest.request({\n      method: 'GET',\n      url: '/human/tasks/{taskId}/conductorTask',\n      path: {\n        'taskId': taskId,\n      },\n    });\n  }\n\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { BaseHttpRequest } from \"./core/BaseHttpRequest\";\nimport type { OpenAPIConfig, Resolver } from \"./core/OpenAPI\";\n\nimport { EventResourceService } from \"./services/EventResourceService\";\nimport { HealthCheckResourceService } from \"./services/HealthCheckResourceService\";\nimport { MetadataResourceService } from \"./services/MetadataResourceService\";\nimport { SchedulerResourceService } from \"./services/SchedulerResourceService\";\nimport { TaskResourceService } from \"./services/TaskResourceService\";\nimport { TokenResourceService } from \"./services/TokenResourceService\";\nimport { WorkflowBulkResourceService } from \"./services/WorkflowBulkResourceService\";\nimport { WorkflowResourceService } from \"./services/WorkflowResourceService\";\nimport { request as baseRequest } from \"./core/request\";\nimport { ConductorHttpRequest } from \"../RequestCustomizer\";\nimport { HumanTaskService } from \"./services/HumanTaskService\";\nimport { HumanTaskResourceService } from \"./services/HumanTaskResourceService\";\n\nexport const defaultRequestHandler: ConductorHttpRequest = (\n  request,\n  config,\n  options\n) => request(config, options);\n\nexport interface ConductorClientAPIConfig extends Omit<OpenAPIConfig, \"BASE\"> {\n  serverUrl: string;\n  useEnvVars: boolean;\n}\n\nconst getServerBaseURL = (config?: Partial<ConductorClientAPIConfig>) => {\n  if (config?.useEnvVars) {\n    if(!process.env.CONDUCTOR_SERVER_URL) {\n      throw new Error(\n        \"Environment variable CONDUCTOR_SERVER_URL is not defined.\"\n      );\n    }\n\n    return process.env.CONDUCTOR_SERVER_URL;\n  }\n\n  return config?.serverUrl ?? \"http://localhost:8080\";\n};\n\nexport class ConductorClient {\n  public readonly eventResource: EventResourceService;\n  public readonly healthCheckResource: HealthCheckResourceService;\n  public readonly metadataResource: MetadataResourceService;\n  public readonly schedulerResource: SchedulerResourceService;\n  public readonly taskResource: TaskResourceService;\n  public readonly tokenResource: TokenResourceService;\n  public readonly workflowBulkResource: WorkflowBulkResourceService;\n  public readonly workflowResource: WorkflowResourceService;\n\n  public readonly humanTask: HumanTaskService;\n  public readonly humanTaskResource: HumanTaskResourceService;\n  public readonly request: BaseHttpRequest;\n\n  public token?: string | Resolver<string>;\n\n  constructor(\n    config?: Partial<ConductorClientAPIConfig>,\n    requestHandler: ConductorHttpRequest = defaultRequestHandler\n  ) {\n    const resolvedConfig = {\n      BASE: getServerBaseURL(config),\n      VERSION: config?.VERSION ?? \"0\",\n      WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,\n      CREDENTIALS: config?.CREDENTIALS ?? \"include\",\n      TOKEN: config?.TOKEN,\n      USERNAME: config?.USERNAME,\n      PASSWORD: config?.PASSWORD,\n      HEADERS: config?.HEADERS,\n      ENCODE_PATH: config?.ENCODE_PATH,\n    };\n\n    // START conductor-client-modification\n    /* The generated models are all based on the concept of an instantiated base http\n    class. To avoid making edits there, we just create an object that satisfies the same\n    interface. Yay typescript!\n     */\n    this.request = {\n      config: resolvedConfig,\n      request: (apiConfig) => {\n        return requestHandler(\n          baseRequest,\n          { ...resolvedConfig, TOKEN: this.token },\n          apiConfig\n        );\n      },\n    };\n    this.token = config?.TOKEN;\n    // END conductor-client-modification\n\n    this.eventResource = new EventResourceService(this.request);\n    this.healthCheckResource = new HealthCheckResourceService(this.request);\n    this.metadataResource = new MetadataResourceService(this.request);\n    this.schedulerResource = new SchedulerResourceService(this.request);\n    this.taskResource = new TaskResourceService(this.request);\n    this.tokenResource = new TokenResourceService(this.request);\n    this.workflowBulkResource = new WorkflowBulkResourceService(this.request);\n    this.workflowResource = new WorkflowResourceService(this.request);\n    this.humanTask = new HumanTaskService(this.request);\n    this.humanTaskResource = new HumanTaskResourceService(this.request);\n  }\n  stop() {}\n}\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { CancelablePromise } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport abstract class BaseHttpRequest {\n\n  constructor(public readonly config: OpenAPIConfig) {}\n\n  public abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;\n}\n","export const DEFAULT_POLL_INTERVAL = 100;\nexport const DEFAULT_CONCURRENCY = 1;\nexport const DEFAULT_WARN_AT_O = 100;\nexport const DEFAULT_BATCH_POLLING_TIMEOUT = 100;","import { ConductorLogger, noopLogger } from \"../common\";\nimport {\n  DEFAULT_POLL_INTERVAL,\n  DEFAULT_WARN_AT_O,\n  DEFAULT_CONCURRENCY,\n} from \"./constants\";\n\ninterface PollerOptions {\n  pollInterval?: number;\n  concurrency: number;\n  warnAtO?: number;\n}\n\nexport class Poller<T> {\n  private timeoutHandler?: NodeJS.Timeout;\n  private pollFunction: (count: number) => Promise<T[]>;\n  private performWorkFunction: (work: T) => Promise<void> = async () => {};\n  private polling = false;\n  private _tasksInProcess = 0;\n  private _counterAtO = 0;\n  private _pollerId: string = \"\";\n  options: PollerOptions = {\n    pollInterval: DEFAULT_POLL_INTERVAL,\n    concurrency: DEFAULT_CONCURRENCY,\n    warnAtO: DEFAULT_WARN_AT_O,\n  };\n  logger: ConductorLogger = noopLogger;\n\n  constructor(\n    pollerId: string,\n    pollFunction: (count: number) => Promise<T[]>,\n    performWorkFunction: (work: T) => Promise<void>,\n    pollerOptions?: Partial<PollerOptions>,\n    logger?: ConductorLogger\n  ) {\n    this._pollerId = pollerId;\n    this.pollFunction = pollFunction;\n    this.performWorkFunction = performWorkFunction;\n    this.options = { ...this.options, ...pollerOptions };\n    this.logger = logger || noopLogger;\n  }\n\n  get isPolling() {\n    return this.polling;\n  }\n\n  get tasksInProcess() {\n    return this._tasksInProcess;\n  }\n\n  /**\n   * Starts polling for work\n   */\n  startPolling = () => {\n    if (this.polling) {\n      throw new Error(\"Runner is already started\");\n    }\n    this._tasksInProcess = 0;\n    this.polling = true;\n    this.poll();\n  };\n\n  /**\n   * Stops Polling for work\n   */\n  stopPolling = async () => {\n    this.polling = false;\n    clearTimeout(this.timeoutHandler!);\n  };\n\n  private performWork = async (work: T) => {\n    await this.performWorkFunction(work);\n    this._tasksInProcess--;\n  };\n\n  updateOptions(options: Partial<PollerOptions>) {\n    const newOptions = { ...this.options, ...options };\n    this.options = newOptions;\n  }\n\n  private poll = async () => {\n    while (this.isPolling) {\n      try {\n        // Concurrency could have been updated. Accounting for that\n        const count = Math.max(\n          0,\n          this.options.concurrency - this._tasksInProcess\n        );\n\n        if (count === 0) {\n          this.logger.debug(\n            \"Max in process reached, Will skip polling for \" + this._pollerId\n          );\n          this._counterAtO++;\n          if (this._counterAtO > (this.options.warnAtO ?? 100)) {\n            this.logger.info(\n              `Not polling anything because in process tasks is maxed as concurrency level. ${this._pollerId}`\n            );\n          }\n        } else {\n          this._counterAtO = 0;\n          const tasksResult: T[] = await this.pollFunction(count);\n          this._tasksInProcess =\n            this._tasksInProcess + (tasksResult ?? []).length;\n\n          // Don't wait for the tasks to finish only 'listen' to the number of tasks being processes\n          tasksResult.forEach(this.performWork);\n        }\n      } catch (e: any) {\n        this.logger.error(`Error polling for tasks: ${e.message}`, e);\n      }\n\n      await new Promise((r) =>\n        this.isPolling\n          ? (this.timeoutHandler = setTimeout(\n              () => r(true),\n              this.options.pollInterval\n            ))\n          : r(true)\n      );\n    }\n  };\n}\n","import { TaskRunnerOptions } from \"./types\";\ntype OptionEntries = Array<\n    [keyof TaskRunnerOptions, string | number | undefined]\n  >;\n\n\n/**\n * Compares if the new options are really new\n * @param oldOptions\n * @param newOptions\n */\nexport const optionEquals = (\n  oldOptions: Partial<TaskRunnerOptions>,\n  newOptions: Partial<TaskRunnerOptions>\n) => {\n  const newOptionEntries = Object.entries(newOptions) as OptionEntries;\n  const oldOptionsEntries = Object.entries(oldOptions) as OptionEntries;\n\n  return newOptionEntries.length === oldOptionsEntries.length && newOptionEntries.every(\n    ([key, value]) => (oldOptions[key] as unknown) === value\n  );\n};\n","import { ConductorLogger, noopLogger } from \"../common\";\nimport { ConductorWorker } from \"./Worker\";\nimport { Task, TaskResourceService, TaskResult } from \"../common/open-api\";\nimport { Poller } from \"./Poller\";\nimport {\n  DEFAULT_POLL_INTERVAL,\n  DEFAULT_BATCH_POLLING_TIMEOUT,\n  DEFAULT_CONCURRENCY,\n} from \"./constants\";\nimport { TaskErrorHandler, TaskRunnerOptions, RunnerArgs } from \"./types\";\nimport { optionEquals } from \"./helpers\";\n\nconst DEFAULT_ERROR_MESSAGE = \"An unknown error occurred\";\nexport const MAX_RETRIES = 3;\n\n//eslint-disable-next-line\nexport const noopErrorHandler: TaskErrorHandler = (__error: Error) => {};\n\nconst defaultRunnerOptions: Required<TaskRunnerOptions> = {\n  workerID: \"\",\n  pollInterval: DEFAULT_POLL_INTERVAL,\n  domain: undefined,\n  concurrency: DEFAULT_CONCURRENCY,\n  batchPollingTimeout: DEFAULT_BATCH_POLLING_TIMEOUT,\n};\n\n/**\n * Responsible for polling and executing tasks from a queue.\n *\n * Because a `poll` in conductor \"pops\" a task off of a conductor queue,\n * each runner participates in the poll -> work -> update loop.\n * We could potentially split this work into a separate \"poller\" and \"worker\" pools\n * but that could lead to picking up more work than the pool of workers are actually able to handle.\n *\n */\nexport class TaskRunner {\n  taskResource: TaskResourceService;\n  worker: ConductorWorker;\n  private logger: ConductorLogger;\n  private options: TaskRunnerOptions;\n  errorHandler: TaskErrorHandler;\n  private poller: Poller<Task>;\n  private maxRetries: number;\n\n  constructor({\n    worker,\n    taskResource,\n    options,\n    logger = noopLogger,\n    onError: errorHandler = noopErrorHandler,\n    maxRetries = MAX_RETRIES,\n  }: RunnerArgs) {\n    this.taskResource = taskResource;\n    this.maxRetries = maxRetries;\n    this.logger = logger;\n    this.worker = worker;\n    this.options = { ...defaultRunnerOptions, ...options };\n    this.errorHandler = errorHandler;\n    this.poller = new Poller(\n      worker.taskDefName,\n      this.batchPoll,\n      this.executeTask,\n      {\n        concurrency: worker.concurrency ?? options.concurrency,\n        pollInterval: worker.pollInterval ?? options.pollInterval,\n      },\n      this.logger\n    );\n  }\n\n  get isPolling() {\n    return this.poller.isPolling;\n  }\n\n  /**\n   * Starts polling for work\n   */\n  startPolling = () => {\n    this.poller.startPolling();\n    this.logger.info(\n      `TaskWorker ${this.worker.taskDefName} initialized with concurrency of ${this.poller.options.concurrency} and poll interval of ${this.poller.options.pollInterval}`\n    );\n  };\n  /**\n   * Stops Polling for work\n   */\n  stopPolling = async () => {\n    await this.poller.stopPolling();\n  };\n\n  updateOptions(options: Partial<TaskRunnerOptions>) {\n    const newOptions = { ...this.options, ...options };\n    const isOptionsUpdated = !optionEquals(this.options, newOptions);\n\n    if (isOptionsUpdated) {\n      this.poller.updateOptions({\n        concurrency: newOptions.concurrency,\n        pollInterval: newOptions.pollInterval,\n      });\n      this.logger.info(\n        `TaskWorker ${this.worker.taskDefName} configuration updated with concurrency of ${this.poller.options.concurrency} and poll interval of ${this.poller.options.pollInterval}`\n      );\n    }\n\n    this.options = newOptions;\n  }\n\n  get getOptions(): TaskRunnerOptions {\n    return this.options;\n  }\n\n  private batchPoll = async (count: number): Promise<Task[]> => {\n    const { workerID } = this.options;\n    const tasks = await this.taskResource.batchPoll(\n      this.worker.taskDefName,\n      workerID,\n      this.worker.domain ?? this.options.domain,\n      count,\n      this.options.batchPollingTimeout ?? 100 // default batch poll defined in the method\n    );\n    return tasks;\n  };\n\n  updateTaskWithRetry = async (task: Task, taskResult: TaskResult) => {\n    const { workerID } = this.options;\n    let retryCount = 0;\n    while (retryCount < this.maxRetries) {\n      try {\n        await this.taskResource.updateTask1({\n          ...taskResult,\n          workerId: workerID,\n        });\n        return;\n      } catch (error: unknown) {\n        this.errorHandler(error as Error, task);\n        this.logger.error(\n          `Error updating task ${taskResult.taskId} on retry ${retryCount}`,\n          error\n        );\n        retryCount++;\n        await new Promise((r) => setTimeout(() => r(true), retryCount * 10));\n      }\n    }\n    this.logger.error(\n      `Unable to update task ${taskResult.taskId} after ${retryCount} retries`\n    );\n  };\n\n  private executeTask = async (task: Task) => {\n    try {\n      const result = await this.worker.execute(task);\n      await this.updateTaskWithRetry(task, {\n        ...result,\n        workflowInstanceId: task.workflowInstanceId!,\n        taskId: task.taskId!,\n      });\n      this.logger.debug(`Task has executed successfully ${task.taskId}`);\n    } catch (error: unknown) {\n      await this.updateTaskWithRetry(task, {\n        workflowInstanceId: task.workflowInstanceId!,\n        taskId: task.taskId!,\n        reasonForIncompletion:\n          (error as Record<string, string>)?.message ?? DEFAULT_ERROR_MESSAGE,\n        status: \"FAILED\",\n        outputData: {},\n      });\n      this.errorHandler(error as Error, task);\n      this.logger.error(`Error executing ${task.taskId}`, error);\n    }\n  };\n\n  handleUnknownError = (unknownError: unknown) => {\n    let message = \"\";\n    let stack: string | undefined = \"\";\n    if ((unknownError as Error).stack) {\n      stack = (unknownError as Error).stack;\n    }\n    if ((unknownError as Error).message) {\n      message = (unknownError as Error).message;\n    }\n    this.logger.error(\n      `Error for ${this.worker.taskDefName}: error: ${message}, stack: ${stack}`\n    );\n  };\n}\n","import os from \"os\";\nimport {\n  TaskRunner,\n  noopErrorHandler,\n  MAX_RETRIES,\n} from \"./TaskRunner\";\nimport { ConductorLogger, DefaultLogger } from \"../common\";\nimport { ConductorWorker } from \"./Worker\";\nimport { ConductorClient } from \"../common/open-api\";\nimport {\n  DEFAULT_POLL_INTERVAL,\n  DEFAULT_BATCH_POLLING_TIMEOUT,\n  DEFAULT_CONCURRENCY,\n} from \"./constants\";\nimport { TaskErrorHandler, TaskRunnerOptions } from \"./types\";\n\nexport type TaskManagerOptions = TaskRunnerOptions;\n\nexport interface TaskManagerConfig {\n  logger?: ConductorLogger;\n  options?: Partial<TaskManagerOptions>;\n  onError?: TaskErrorHandler;\n  maxRetries?: number;\n}\n\nconst defaultManagerOptions: Required<TaskManagerOptions> = {\n  workerID: \"\",\n  pollInterval: DEFAULT_POLL_INTERVAL,\n  domain: undefined,\n  concurrency: DEFAULT_CONCURRENCY,\n  batchPollingTimeout: DEFAULT_BATCH_POLLING_TIMEOUT,\n};\n\nfunction workerId(options: Partial<TaskManagerOptions>) {\n  return options.workerID ?? os.hostname();\n}\n\n/**\n * Responsible for initializing and managing the runners that poll and work different task queues.\n */\nexport class TaskManager {\n  private workerRunners: Map<string, TaskRunner> = new Map();\n  private readonly client: ConductorClient;\n  private readonly logger: ConductorLogger;\n  private readonly errorHandler: TaskErrorHandler;\n  private workers: Array<ConductorWorker>;\n  readonly options: Required<TaskManagerOptions>;\n  private polling: boolean = false;\n  private maxRetries: number = MAX_RETRIES;\n\n  constructor(\n    client: ConductorClient,\n    workers: Array<ConductorWorker>,\n    config: TaskManagerConfig = {}\n  ) {\n    if (!workers) {\n      throw new Error(\n        \"No workers supplied to TaskManager. Please pass an array of workers.\"\n      );\n    }\n    this.client = client;\n    this.logger = config.logger ?? new DefaultLogger();\n    this.maxRetries = config.maxRetries ?? MAX_RETRIES;\n    this.errorHandler = config.onError ?? noopErrorHandler;\n    this.workers = workers;\n    const providedOptions = config.options ?? {};\n    this.options = {\n      ...defaultManagerOptions,\n      ...providedOptions,\n      workerID: workerId(providedOptions),\n    };\n  }\n\n  private workerManagerWorkerOptions = (\n    worker: ConductorWorker\n  ): Required<TaskManagerOptions> => {\n    return {\n      ...this.options,\n      concurrency: worker.concurrency ?? this.options.concurrency,\n      pollInterval: worker.pollInterval ?? this.options.pollInterval,\n      domain: worker.domain ?? this.options.domain,\n    };\n  };\n\n  get isPolling() {\n    return this.polling;\n  }\n\n  updatePollingOptionForWorker = (\n    workerTaskDefName: string,\n    options: Partial<TaskManagerOptions>\n  ) => {\n    const maybeRunner = this.workerRunners.get(workerTaskDefName);\n\n    if (maybeRunner != null) {\n      maybeRunner.updateOptions(options);\n    } else {\n      this.logger.info(\n        `No runner found for worker with taskDefName: ${workerTaskDefName}`\n      );\n    }\n  };\n\n  /**\n   * new options will get merged to existing options\n   * @param options new options to update polling options\n   */\n  updatePollingOptions = (options: Partial<TaskManagerOptions>) => {\n    this.workers.forEach((worker) => {\n      const newOptions = {\n        ...this.workerManagerWorkerOptions(worker),\n        ...options,\n      };\n      this.updatePollingOptionForWorker(worker.taskDefName, newOptions);\n    });\n    this.options.concurrency = options.concurrency ?? this.options.concurrency;\n    this.options.pollInterval =\n      options.pollInterval ?? this.options.pollInterval;\n  };\n\n  sanityCheck = () => {\n    if (this.workers.length === 0) {\n      throw new Error(\"No workers supplied to TaskManager\");\n    }\n    const workerIDs = new Set();\n    for (const item of this.workers) {\n      if (workerIDs.has(item.taskDefName)) {\n        throw new Error(`Duplicate worker taskDefName: ${item.taskDefName}`);\n      }\n      workerIDs.add(item.taskDefName);\n    }\n  };\n\n  /**\n   * Start polling for tasks\n   */\n  startPolling = () => {\n    this.sanityCheck();\n    this.workers.forEach((worker) => {\n      const options = this.workerManagerWorkerOptions(worker);\n      const runner = new TaskRunner({\n        worker,\n        options,\n        taskResource: this.client.taskResource,\n        logger: this.logger,\n        onError: this.errorHandler,\n        maxRetries: this.maxRetries,\n      });\n      runner.startPolling();\n      this.workerRunners.set(worker.taskDefName, runner);\n    });\n    this.polling = true;\n  };\n  /**\n   * Stops polling for tasks\n   */\n  stopPolling = async () => {\n    for (const [workerTaskDefName, runner] of this.workerRunners) {\n      this.logger.debug(`Stopping taskDefName=${workerTaskDefName}`);\n      await runner.stopPolling();\n      this.workerRunners.delete(workerTaskDefName);\n    }\n    this.polling = false;\n  };\n}\n","import { TaskResult }  from \"../common/open-api\";\nexport class ConductorError extends Error {\n  private _trace;\n  private __proto__: any;\n\n  constructor(message?: string, innerError?: Error) {\n    super(message);\n    this._trace = innerError;\n    const actualProto = new.target.prototype;\n\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n  }\n}\nexport type TaskResultStatus = NonNullable<TaskResult['status']>;","import { ConductorError } from \"./types\";\n\nexport const errorMapper = (error: any): ConductorError =>\n  new ConductorError(error?.body?.message, error);\n\nexport const tryCatchReThrow = (fn: Function) => {\n  try {\n    return fn();\n  } catch (error) {\n    throw errorMapper(error);\n  }\n};\n\nexport function reverseFind<T>(\n  array: T[],\n  predicate: (a: T, idx?: number, arr?: T[]) => boolean\n): T | undefined {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (predicate(array[i], i, array)) {\n      return array[i];\n    }\n  }\n  return undefined;\n}\n","import { ConductorClient, WorkflowDef } from \"../common\";\nimport {\n  Workflow,\n  Task,\n  RerunWorkflowRequest,\n  StartWorkflowRequest,\n  SkipTaskRequest,\n  WorkflowRun,\n  WorkflowStatus,\n  ScrollableSearchResultWorkflowSummary,\n} from \"../common/open-api\";\nimport { TaskResultStatus } from \"./types\";\nimport { errorMapper, reverseFind, tryCatchReThrow } from \"./helpers\";\n\nconst RETRY_TIME_IN_MILLISECONDS = 10000;\n\nexport type TaskFinderPredicate = (task: Task) => boolean;\n\nexport const completedTaskMatchingType =\n  (taskType: string): TaskFinderPredicate =>\n  (task: Task) =>\n    task.status === \"COMPLETED\" && task.taskType === taskType;\n\nexport class WorkflowExecutor {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n  /**\n   * Will persist a workflow in conductor\n   * @param override If true will override the existing workflow with the definition\n   * @param workflow Complete workflow definition\n   * @returns null\n   */\n\n  public registerWorkflow(\n    override: boolean,\n    workflow: WorkflowDef\n  ): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.metadataResource.create(workflow, override)\n    );\n  }\n  /**\n   * Takes a StartWorkflowRequest. returns a Promise<string> with the workflowInstanceId of the running workflow\n   * @param workflowRequest\n   * @returns\n   */\n  public startWorkflow(workflowRequest: StartWorkflowRequest): Promise<string> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.startWorkflow(workflowRequest)\n    );\n  }\n\n  /**\n   * Execute a workflow synchronously. returns a Promise<WorkflowRun> with details of the running workflow\n   * @param workflowRequest\n   * @returns\n   */\n  public executeWorkflow(\n    workflowRequest: StartWorkflowRequest,\n    name: string,\n    version: number,\n    requestId: string,\n    waitUntilTaskRef: string = \"\"\n  ): Promise<WorkflowRun> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.executeWorkflow(\n        workflowRequest,\n        name,\n        version,\n        requestId,\n        waitUntilTaskRef\n      )\n    );\n  }\n\n  public startWorkflows(\n    workflowsRequest: StartWorkflowRequest[]\n  ): Promise<string>[] {\n    return tryCatchReThrow(() => workflowsRequest.map(this.startWorkflow));\n  }\n\n  public async goBackToTask(\n    workflowInstanceId: string,\n    taskFinderPredicate: TaskFinderPredicate,\n    rerunWorkflowRequestOverrides: Partial<RerunWorkflowRequest> = {}\n  ): Promise<void> {\n    const { tasks: executedTasks = [] } = await this.getExecution(\n      workflowInstanceId\n    );\n    const maybePreviousTask = reverseFind<Task>(\n      executedTasks,\n      taskFinderPredicate\n    );\n\n    if (!maybePreviousTask) {\n      throw new Error(\"Task not found\");\n    }\n\n    await this.reRun(workflowInstanceId, {\n      //taskInput: previousTask.inputData,\n      ...rerunWorkflowRequestOverrides,\n      reRunFromTaskId: maybePreviousTask.taskId,\n    });\n  }\n  \n  public async goBackToFirstTaskMatchingType(workflowInstanceId: string, taskType: string): Promise<void> {\n    return this.goBackToTask(workflowInstanceId, completedTaskMatchingType(taskType));\n  }\n\n  /**\n   * Takes an workflowInstanceId and an includeTasks and an optional retry parameter returns the whole execution status.\n   * If includeTasks flag is provided. Details of tasks execution will be returned as well,\n   * retry specifies the amount of retrys before throwing an error.\n   *\n   * @param workflowInstanceId\n   * @param includeTasks\n   * @param retry\n   * @returns\n   */\n  public async getWorkflow(\n    workflowInstanceId: string,\n    includeTasks: boolean,\n    retry: number = 0\n  ): Promise<Workflow> {\n    try {\n      const workflowStatus =\n        await this._client.workflowResource.getExecutionStatus(\n          workflowInstanceId,\n          includeTasks\n        );\n      return workflowStatus;\n    } catch (error: any) {\n      if (![500, 404, 403].includes(error.status) || retry === 0) {\n        throw errorMapper(error);\n      }\n    }\n\n    await new Promise((res) =>\n      setTimeout(() => res(true), RETRY_TIME_IN_MILLISECONDS)\n    );\n\n    return this.getWorkflow(workflowInstanceId, includeTasks, retry - 1);\n  }\n\n  /**\n   *  Returns a summary of the current workflow status.\n   *\n   * @param workflowInstanceId current running workflow\n   * @param includeOutput flag to include output\n   * @param includeVariables flag to include variable\n   * @returns Promise<WorkflowStatus>\n   */\n  public getWorkflowStatus(\n    workflowInstanceId: string,\n    includeOutput: boolean,\n    includeVariables: boolean\n  ): Promise<WorkflowStatus> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.getWorkflowStatusSummary(\n        workflowInstanceId,\n        includeOutput,\n        includeVariables\n      )\n    );\n  }\n\n  /**\n   *  Returns a summary of the current workflow status.\n   *\n   * @param workflowInstanceId current running workflow\n   * @param includeOutput flag to include output\n   * @param includeVariables flag to include variable\n   * @returns Promise<WorkflowStatus>\n   */\n  public getExecution(\n    workflowInstanceId: string,\n    includeTasks: boolean = true\n  ): Promise<Workflow> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.getExecutionStatus(\n        workflowInstanceId,\n        includeTasks\n      )\n    );\n  }\n\n  /**\n   * Pauses a running workflow\n   * @param workflowInstanceId current workflow execution\n   * @returns\n   */\n  public pause(workflowInstanceId: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.pauseWorkflow(workflowInstanceId)\n    );\n  }\n  /**\n   * Reruns workflowInstanceId workflow. with new parameters\n   *\n   * @param workflowInstanceId current workflow execution\n   * @param rerunWorkflowRequest Rerun Workflow Execution Request\n   * @returns\n   */\n  public reRun(\n    workflowInstanceId: string,\n    rerunWorkflowRequest: Partial<RerunWorkflowRequest> = {}\n  ): Promise<string> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.rerun(\n        workflowInstanceId,\n        rerunWorkflowRequest\n      )\n    );\n  }\n\n  /**\n   * Restarts workflow with workflowInstanceId, if useLatestDefinition uses last defintion\n   * @param workflowInstanceId\n   * @param useLatestDefinitions\n   * @returns\n   */\n  public restart(\n    workflowInstanceId: string,\n    useLatestDefinitions: boolean\n  ): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.restart1(\n        workflowInstanceId,\n        useLatestDefinitions\n      )\n    );\n  }\n\n  /**\n   * Resumes a previously paused execution\n   *\n   * @param workflowInstanceId Running workflow workflowInstanceId\n   * @returns\n   */\n  public resume(workflowInstanceId: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.resumeWorkflow(workflowInstanceId)\n    );\n  }\n\n  /**\n   * Retrys workflow from last failing task\n   * if resumeSubworkflowTasks is true will resume tasks in spawned subworkflows\n   *\n   * @param workflowInstanceId\n   * @param resumeSubworkflowTasks\n   * @returns\n   */\n  public retry(\n    workflowInstanceId: string,\n    resumeSubworkflowTasks: boolean\n  ): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.retry1(\n        workflowInstanceId,\n        resumeSubworkflowTasks\n      )\n    );\n  }\n  /**\n   * Searches for existing workflows given the following querys\n   *\n   * @param start\n   * @param size\n   * @param query\n   * @param freeText\n   * @param sort\n   * @param skipCache\n   * @returns\n   */\n  public search(\n    start: number,\n    size: number,\n    query: string,\n    freeText: string,\n    sort: string = \"\",\n    skipCache: boolean = false\n  ): Promise<ScrollableSearchResultWorkflowSummary> {\n    const queryId = undefined;\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.search1(\n        queryId,\n        start,\n        size,\n        sort,\n        freeText,\n        query,\n        skipCache\n      )\n    );\n  }\n  /**\n   * Skips a task of a running workflow.\n   * by providing a skipTaskRequest you can set the input and the output of the skipped tasks\n   * @param workflowInstanceId\n   * @param taskReferenceName\n   * @param skipTaskRequest\n   * @returns\n   */\n  public skipTasksFromWorkflow(\n    workflowInstanceId: string,\n    taskReferenceName: string,\n    skipTaskRequest: Partial<SkipTaskRequest>\n  ): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.skipTaskFromWorkflow(\n        workflowInstanceId,\n        taskReferenceName,\n        skipTaskRequest\n      )\n    );\n  }\n  /**\n   * Takes an workflowInstanceId, and terminates a running workflow\n   * @param workflowInstanceId\n   * @param reason\n   * @returns\n   */\n  public terminate(workflowInstanceId: string, reason: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.workflowResource.terminate1(workflowInstanceId, reason)\n    );\n  }\n\n  /**\n   * Takes a taskId and a workflowInstanceId. Will update the task for the corresponding taskId\n   * @param taskId\n   * @param workflowInstanceId\n   * @param taskStatus\n   * @param taskOutput\n   * @returns\n   */\n  public updateTask(\n    taskId: string,\n    workflowInstanceId: string,\n    taskStatus: TaskResultStatus,\n    outputData: Record<string, any> // TODO this can be typed.\n  ): Promise<string> {\n    const taskUpdates = {\n      status: taskStatus,\n      taskId,\n      workflowInstanceId,\n    };\n    return tryCatchReThrow(() =>\n      this._client.taskResource.updateTask1({\n        outputData,\n        ...taskUpdates,\n      })\n    );\n  }\n\n  /**\n   * Updates a task by reference Name\n   * @param taskReferenceName\n   * @param workflowInstanceId\n   * @param status\n   * @param taskOutput\n   * @returns\n   */\n  public updateTaskByRefName(\n    taskReferenceName: string,\n    workflowInstanceId: string,\n    status: TaskResultStatus,\n    taskOutput: Record<string, any>\n  ): Promise<string> {\n    return tryCatchReThrow(() =>\n      this._client.taskResource.updateTask(\n        workflowInstanceId,\n        taskReferenceName,\n        status,\n        taskOutput\n      )\n    );\n  }\n\n  /**\n   *\n   * @param taskId\n   * @returns\n   */\n  public getTask(taskId: string): Promise<Task> {\n    return tryCatchReThrow(() => this._client.taskResource.getTask(taskId));\n  }\n}\n","import {\n  ConductorClient,\n  HumanTaskSearch,\n  HumanTaskEntry,\n  HumanTaskTemplate,\n} from \"../common\";\nimport { errorMapper, tryCatchReThrow } from \"./helpers\";\n\ntype UserType =\n  | \"EXTERNAL_USER\"\n  | \"EXTERNAL_GROUP\"\n  | \"CONDUCTOR_USER\"\n  | \"CONDUCTOR_GROUP\";\n\nconst EMPTY_SEARCH: HumanTaskSearch = {\n  size: 15,\n  states: [],\n  taskInputQuery: \"\",\n  taskOutputQuery: \"\",\n  definitionNames: [],\n  taskRefNames: [],\n  claimants: [],\n  assignees: [],\n  start: 0,\n};\n\nconst DEFAULT_POLL_INTERVAL = { pollInterval: 100, maxPollTimes: 20 };\n\ntype PollIntervalOptions = {\n  pollInterval: number;\n  maxPollTimes: number;\n};\nexport class HumanExecutor {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n\n  /**\n   * @deprecated use search instead\n   * Takes a set of filter parameters. return matches of human tasks for that set of parameters\n   * @param state\n   * @param assignee\n   * @param assigneeType\n   * @param claimedBy\n   * @param taskName\n   * @param freeText\n   * @param includeInputOutput\n   * @returns\n   */\n  public async getTasksByFilter(\n    state: \"PENDING\" | \"ASSIGNED\" | \"IN_PROGRESS\" | \"COMPLETED\" | \"TIMED_OUT\",\n    assignee?: string,\n    assigneeType?:\n      | \"EXTERNAL_USER\"\n      | \"EXTERNAL_GROUP\"\n      | \"CONDUCTOR_USER\"\n      | \"CONDUCTOR_GROUP\",\n    claimedBy?: string,\n    taskName?: string,\n    taskInputQuery?: string,\n    taskOutputQuery?: string,\n  ): Promise<HumanTaskEntry[]> {\n    const [claimedUserType, claimedUser] = claimedBy?.split(\":\") ?? [];\n\n    if (claimedUserType && !claimedUser) {\n      throw new Error(\"claimedBy should be in the format of <userType>:<user>\");\n    }\n\n    const response = await this.search({\n      states: [state],\n      assignees: assignee ? [{ userType: assigneeType!, user: assignee }] : [],\n      claimants: claimedBy\n        ? [{ userType: claimedUserType as UserType, user: claimedUser }]\n        : [],\n      taskRefNames: taskName ? [taskName] : [],\n      taskInputQuery,\n      taskOutputQuery\n    });\n\n    return response;\n  }\n\n  /**\n   * Takes a set of filter parameters. return matches of human tasks for that set of parameters\n   * @param state\n   * @param assignee\n   * @param assigneeType\n   * @param claimedBy\n   * @param taskName\n   * @param freeText\n   * @param includeInputOutput\n   * @returns Promise<HumanTaskEntry[]>\n   */\n  public async search(\n    searchParams: Partial<HumanTaskSearch>\n  ): Promise<HumanTaskEntry[]> {\n    const search = { ...EMPTY_SEARCH, ...searchParams };\n    const response = await tryCatchReThrow(() =>\n      this._client.humanTask.search(search)\n    );\n    if (response.results != undefined) {\n      return response.results;\n    }\n    return [];\n  }\n\n  /**\n   * Takes a set of filter parameters. An polling interval options. will poll until the task returns a result\n   * @param state\n   * @param assignee\n   * @param assigneeType\n   * @param claimedBy\n   * @param taskName\n   * @param freeText\n   * @param includeInputOutput\n   * @returns Promise<HumanTaskEntry[]>\n   */\n  public async pollSearch(\n    searchParams: Partial<HumanTaskSearch>,\n    {\n      pollInterval = 100,\n      maxPollTimes = 20,\n    }: PollIntervalOptions = DEFAULT_POLL_INTERVAL\n  ): Promise<HumanTaskEntry[]> {\n    let pollCount = 0;\n    while (pollCount < maxPollTimes) {\n      const response = await this.search(searchParams);\n      if (response.length > 0) {\n        return response;\n      }\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n      pollCount++;\n    }\n    return [];\n  }\n\n  /**\n   * Returns task for a given task id\n   * @param taskId\n   * @returns\n   */\n  public getTaskById(taskId: string): Promise<HumanTaskEntry> {\n    return tryCatchReThrow(() => this._client.humanTask.getTask1(taskId!));\n  }\n\n  /**\n   * Assigns taskId to assignee. If the task is already assigned to another user, this will fail.\n   * @param taskId\n   * @param assignee\n   * @returns\n   */\n  public async claimTaskAsExternalUser(\n    taskId: string,\n    assignee: string,\n    options?:Record<string,boolean>\n  ): Promise<HumanTaskEntry> {\n    return tryCatchReThrow(() =>\n      this._client.humanTask.assignAndClaim(taskId, assignee,options?.overrideAssignment,options?.withTemplate)\n    );\n  }\n\n  /**\n   * Claim task as conductor user\n   * @param taskId\n   * @returns\n   */\n  public async claimTaskAsConductorUser(\n    taskId: string,\n    options?:Record<string,boolean>\n  ): Promise<HumanTaskEntry> {\n    return tryCatchReThrow(() => this._client.humanTask.claimTask(taskId,options?.overrideAssignment,options?.withTemplate));\n  }\n\n  /**\n   * Claim task as conductor user\n   * @param taskId\n   * @param assignee\n   * @returns\n   */\n  public async releaseTask(taskId: string) {\n    try {\n      await this._client.humanTask.releaseTask(taskId);\n    } catch (error: any) {\n      throw errorMapper(error);\n    }\n  }\n\n  /**\n   * Returns a HumanTaskTemplateEntry for a given name and version\n   * @param templateId\n   * @returns\n   */\n  public async getTemplateByNameVersion(\n    name: string,\n    version: number\n  ): Promise<HumanTaskTemplate> {\n    return tryCatchReThrow(() =>\n      this._client.humanTask.getTemplateByNameAndVersion(name, version)\n    );\n  }\n\n  /**\n   * @deprecated use getTemplate instead. name will be used as id here with version 1\n   * Returns a HumanTaskTemplateEntry for a given templateId\n   * @param templateId\n   * @returns\n   */\n  public async getTemplateById(\n    templateNameVersionOne: string\n  ): Promise<HumanTaskTemplate> {\n    return this.getTemplateByNameVersion(templateNameVersionOne, 1);\n  }\n\n  /**\n   * Takes a taskId and a partial body. will update with given body\n   * @param taskId\n   * @param requestBody\n   */\n  public async updateTaskOutput(\n    taskId: string,\n    requestBody: Record<string, Record<string, any>>\n  ) {\n    try {\n      await this._client.humanTask.updateTaskOutput(taskId, requestBody, false);\n    } catch (error: any) {\n      throw errorMapper(error);\n    }\n  }\n\n  /**\n   * Takes a taskId and an optional partial body. will complete the task with the given body\n   * @param taskId\n   * @param requestBody\n   */\n  public async completeTask(\n    taskId: string,\n    requestBody: Record<string, Record<string, any>> = {}\n  ) {\n    try {\n      await this._client.humanTask.updateTaskOutput(taskId, requestBody, true);\n    } catch (error: any) {\n      throw errorMapper(error);\n    }\n  }\n}\n","import { TaskType, DoWhileTaskDef, TaskDefTypes } from \"../../common/types\";\n\nexport const doWhileTask = (\n  taskRefName: string,\n  terminationCondition: string,\n  tasks: TaskDefTypes[]\n): DoWhileTaskDef => ({\n  name: taskRefName,\n  taskReferenceName: taskRefName,\n  loopCondition: terminationCondition,\n  inputParameters: {},\n  type: TaskType.DO_WHILE,\n  loopOver: tasks,\n});\n\nconst loopForCondition = (taskRefName: string, valueKey: string) =>\n  `if ( $.${taskRefName}['iteration'] < $.${valueKey} ) { true; } else { false; }`;\n\nexport const newLoopTask = (\n  taskRefName: string,\n  iterations: number,\n  tasks: TaskDefTypes[]\n): DoWhileTaskDef => ({\n  name: taskRefName,\n  taskReferenceName: taskRefName,\n  loopCondition: loopForCondition(taskRefName, \"value\"),\n  inputParameters: {\n    value: iterations,\n  },\n  type: TaskType.DO_WHILE,\n  loopOver: tasks,\n});\n","import { TaskType, ForkJoinDynamicDef, TaskDefTypes } from \"../../common/types\";\n\nexport const dynamicForkTask = (\n  taskReferenceName: string,\n  preForkTasks: TaskDefTypes[] = [],\n  dynamicTasksInput: string = \"\"\n): ForkJoinDynamicDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  inputParameters: {\n    dynamicTasks: preForkTasks,\n    dynamicTasksInput,\n  },\n  type: TaskType.FORK_JOIN_DYNAMIC,\n  dynamicForkTasksParam: \"dynamicTasks\",\n  dynamicForkTasksInputParamName: \"dynamicTasksInput\",\n});\n","import { TaskType, EventTaskDef } from \"../../common/types\";\n\nexport const eventTask = (\n  taskReferenceName: string,\n  eventPrefix: string,\n  eventSuffix: string\n): EventTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  sink: `${eventPrefix}:${eventSuffix}`,\n  type: TaskType.EVENT,\n});\n\nexport const sqsEventTask = (taskReferenceName: string, queueName: string) =>\n  eventTask(taskReferenceName, \"sqs\", queueName);\n\nexport const conductorEventTask = (\n  taskReferenceName: string,\n  eventName: string\n) => eventTask(taskReferenceName, \"conductor\", eventName);\n","export const randomChars = (n = 7): string =>\n  (Math.random() + 1).toString(36).substring(n);\n\nexport const workflowNameGenerator = () => `workflow___${randomChars(7)}`;\n\nexport const taskNameGenerator = (taskType: string) =>\n  `${taskType}__task_${randomChars(7)}`;\n\nexport const taskReferenceNameGenerator = (taskName: string) =>\n  `${taskName}_ref`;\n\ninterface MaybeOverrides {\n  name?: string;\n}\n\nexport const nameTaskNameGenerator = (\n  taskType: string,\n  maybeOverrides: MaybeOverrides = {}\n) => {\n  const name = maybeOverrides?.name ?? taskNameGenerator(taskType);\n  return {\n    name,\n    taskReferenceName: taskReferenceNameGenerator(name),\n  };\n};\n\nexport function mapArrValues<T, R>(\n  arrayTransformer: (a: T[]) => R[],\n  mapWithValues: Record<string, T[]>\n) {\n  return Object.fromEntries(\n    Object.entries(mapWithValues).map(([key, value]: [string, T[]]) => [\n      key,\n      arrayTransformer(value),\n    ])\n  );\n}\n","import { SimpleTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial SimpleTaskDef\n * generates a task replacing default values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateSimpleTask = (\n  overrides: Partial<SimpleTaskDef> = {}\n): SimpleTaskDef => ({\n  ...nameTaskNameGenerator(\"simple\", overrides),\n  inputParameters: {},\n  ...overrides,\n  type: TaskType.SIMPLE,\n});\n","import { TaskType, DoWhileTaskDef } from \"../../common/types\";\nimport { DoWhileTaskDefGen, NestedTaskMapper } from \"./types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\nexport const generateDoWhileTask = (\n  overrides: Partial<DoWhileTaskDefGen> = {},\n  nestedTasksMapper: NestedTaskMapper\n): DoWhileTaskDef => ({\n  ...nameTaskNameGenerator(\"doWhile\", overrides),\n  inputParameters: {},\n  startDelay: 0,\n  optional: false,\n  asyncComplete: false,\n  loopCondition:\"\",\n  ...overrides,\n  loopOver: nestedTasksMapper(overrides?.loopOver || []),\n  type: TaskType.DO_WHILE,\n});\n","import { EventTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial EventTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateEventTask = (\n  overrides: Partial<EventTaskDef> = {}\n): EventTaskDef => ({\n  ...nameTaskNameGenerator(\"event\", overrides),\n  sink: \"sqs:sqs_queue_name\",\n  asyncComplete: false,\n  ...overrides,\n  type: TaskType.EVENT,\n});\n","import { ForkJoinTaskDef, JoinTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\nimport { ForkJoinTaskDefGen, NestedTaskMapper } from \"./types\";\n\nexport const generateForkJoinTask = (\n  overrides: Partial<ForkJoinTaskDefGen> = {},\n  nestedMapper: NestedTaskMapper\n): ForkJoinTaskDef => ({\n  ...nameTaskNameGenerator(\"forkJoin\", overrides),\n  inputParameters: {},\n  ...overrides,\n  type: TaskType.FORK_JOIN,\n  forkTasks: (overrides?.forkTasks || []).map(nestedMapper),\n});\n\nexport const generateJoinTask = (\n  overrides: Partial<JoinTaskDef> = {}\n): JoinTaskDef => ({\n  ...nameTaskNameGenerator(\"join\", overrides),\n  inputParameters: {},\n  joinOn: [],\n  optional: false,\n  asyncComplete: false,\n  ...overrides,\n  type: TaskType.JOIN,\n});\n","import { HttpTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial HttpTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateHTTPTask = (\n overrides: Partial<HttpTaskDef> = {}\n): HttpTaskDef => ({\n  ...nameTaskNameGenerator(\"httpTask\", overrides),\n  inputParameters: {\n    http_request: {\n      uri: \"https://jsonplaceholder.typicode.com/posts/${workflow.input.queryid}\",\n      method: \"GET\",\n    },\n  },\n  ...overrides,\n  type: TaskType.HTTP,\n});\n","import { InlineTaskDef, TaskType, InlineTaskInputParameters } from \"../../common/types\";\nimport { InlineTaskDefGen, InlineTaskInputParametersGen } from \"./types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\nconst defaultInputParams: InlineTaskInputParameters = {\n  value: \"${workflow.input.value}\",\n  evaluatorType: \"graaljs\",\n  expression: \"true\",\n};\n\nexport const generateEvaluationCode = (\n  inputParametersPartial: Partial<InlineTaskInputParametersGen> = {}\n): InlineTaskInputParameters => {\n  const inlinePartialDefJavascript = inputParametersPartial;\n  const inlineExpression = inlinePartialDefJavascript?.expression;\n  if (\n    inlineExpression !== undefined &&\n    typeof inlineExpression === \"function\"\n  ) {\n    const resultingFunction = inlineExpression();\n    const resultingFunctionAsString = resultingFunction.toString();\n\n    const toReturn: InlineTaskInputParameters = {\n      evaluatorType: \"graaljs\",\n      ...(inputParametersPartial || { value: \"true\" }),\n      expression: `(${resultingFunctionAsString})();`,\n    };\n    return toReturn;\n  }\n  return {\n    ...defaultInputParams,\n    evaluatorType: \"graaljs\",\n    ...inputParametersPartial,\n  } as InlineTaskInputParameters;\n};\n\n/**\n * Takes an optional partial InlineTaskDefGen\n * generates a task replacing default/fake values with provided overrides\n *\n * <b>note</b> that the inputParameters.expression can be either a string containing javascript\n * or a function thar returns an ES5 function\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateInlineTask = (\n  override: Partial<InlineTaskDefGen> = {}\n): InlineTaskDef => ({\n  ...nameTaskNameGenerator(\"inline\", override),\n  ...override,\n  inputParameters: generateEvaluationCode(override?.inputParameters || {}),\n  type: TaskType.INLINE,\n});\n","import { JsonJQTransformTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial JsonJQTransformTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateJQTransformTask = (\n  overrides: Partial<JsonJQTransformTaskDef> = {}\n): JsonJQTransformTaskDef => ({\n  ...nameTaskNameGenerator(\"jqTransform\", overrides),\n  inputParameters: {\n    key1: {\n      value1: [\"a\", \"b\"],\n    },\n    key2: {\n      value2: [\"c\", \"d\"],\n    },\n    queryExpression: \"{ key3: (.key1.value1 + .key2.value2) }\",\n  },\n  ...overrides,\n  type: TaskType.JSON_JQ_TRANSFORM,\n});\n","import { KafkaPublishTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial KafkaPublishTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateKafkaPublishTask = (\n  overrides: Partial<KafkaPublishTaskDef> = {}\n): KafkaPublishTaskDef => ({\n  ...nameTaskNameGenerator(\"kafka\", overrides),\n  inputParameters: {\n    kafka_request: {\n      topic: \"topic\",\n      value: \"\",\n      bootStrapServers: \"localhost:9092\",\n      headers: {},\n      key: \"123\",\n      keySerializer: \"org.apache.kafka.common.serialization.IntegerSerializer\",\n    },\n  },\n  ...overrides,\n  type: TaskType.KAFKA_PUBLISH,\n});\n","import { SubWorkflowTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial SubWorkflowTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateSubWorkflowTask = (\n  overrides: Partial<SubWorkflowTaskDef> = {}\n): SubWorkflowTaskDef => ({\n  ...nameTaskNameGenerator(\"subWorkflow\", overrides),\n  inputParameters: {},\n  subWorkflowParam: {\n    name: \"name\",\n    version: 1,\n    taskToDomain: {},\n  },\n  ...overrides,\n  type: TaskType.SUB_WORKFLOW,\n});\n","import { SetVariableTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial SetVariableTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateSetVariableTask = (\n  overrides: Partial<SetVariableTaskDef> = {}\n): SetVariableTaskDef => ({\n  ...nameTaskNameGenerator(\"setVariable\", overrides),\n  inputParameters: {},\n  ...overrides,\n  type: TaskType.SET_VARIABLE,\n});\n","import { TerminateTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial TerminateTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateTerminateTask = (\n  overrides: Partial<TerminateTaskDef> = {}\n): TerminateTaskDef => ({\n  ...nameTaskNameGenerator(\"terminate\", overrides),\n  inputParameters: {\n    terminationStatus: \"COMPLETED\",\n    workflowOutput: {},\n  },\n  startDelay: 0,\n  optional: false,\n  ...overrides,\n  type: TaskType.TERMINATE,\n});\n","import { WaitTaskDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\n/**\n * Takes an optional partial WaitTaskDef\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generateWaitTask = (\n  overrides: Partial<WaitTaskDef> = {}\n): WaitTaskDef => ({\n  ...nameTaskNameGenerator(\"wait\", overrides),\n  ...overrides,\n  inputParameters:{},\n  type: TaskType.WAIT,\n});\n","import { SwitchTaskDef, TaskType, TaskDefTypes } from \"../../common/types\";\nimport { nameTaskNameGenerator, mapArrValues } from \"./common\";\nimport { NestedTaskMapper, SwitchTaskDefGen } from \"./types\";\n\ntype DefinedCases = {\n  decisionCases: Record<string, TaskDefTypes[]>;\n  defaultCase: TaskDefTypes[];\n};\n\nconst fillSwitchTaskBranches = (\n  task: Partial<SwitchTaskDefGen>,\n  mapper: NestedTaskMapper\n): DefinedCases => ({\n  decisionCases: mapArrValues(mapper, task?.decisionCases || {}),\n  defaultCase: mapper(task?.defaultCase || []),\n});\n\nexport const generateSwitchTask = (\n  overrides: Partial<SwitchTaskDefGen> = {},\n  nestedTasksMapper: NestedTaskMapper\n): SwitchTaskDef => ({\n  ...nameTaskNameGenerator(\"switch\", overrides),\n  inputParameters: {\n    switchCaseValue: \"\",\n  },\n  evaluatorType: \"value-param\",\n  expression: \"switchCaseValue\",\n  ...overrides,\n  ...fillSwitchTaskBranches(overrides, nestedTasksMapper),\n  type: TaskType.SWITCH,\n});\n","import { WorkflowDef } from \"../../common/types\";\n\nexport const workflowGenerator = (\n  overrides: Partial<WorkflowDef>\n): WorkflowDef => ({\n  name: \"NewWorkflow_3nxbi\",\n  description:\n    \"Edit or extend this sample workflow. Set the workflow name to get started\",\n  version: 1,\n  tasks: [],\n  inputParameters: [],\n  outputParameters: {},\n  schemaVersion: 2,\n  restartable: true,\n  workflowStatusListenerEnabled: false,\n  ownerEmail: \"james.stuart@orkes.io\",\n  timeoutPolicy: \"ALERT_ONLY\",\n  timeoutSeconds: 0,\n  ...overrides,\n});\n","import { ForkJoinDynamicDef, TaskType } from \"../../common/types\";\nimport { nameTaskNameGenerator } from \"./common\";\n\nexport const generateForkJoinDynamic = (\n  overrides: Partial<ForkJoinDynamicDef> = {}\n): ForkJoinDynamicDef => ({\n  ...nameTaskNameGenerator(\"forkJoinDynamic\", overrides),\n  inputParameters: {\n    dynamicTasks: \"\",\n    dynamicTasksInput: \"\",\n  },\n  dynamicForkTasksParam: \"dynamicTasks\",\n  dynamicForkTasksInputParamName: \"dynamicTasksInput\",\n  startDelay: 0,\n  optional: false,\n  asyncComplete: false,\n  ...overrides,\n  type: TaskType.FORK_JOIN_DYNAMIC,\n});\n","import { workflowGenerator } from \"./WorkflowGenerator\";\nimport { WorkflowDefGen, TaskDefTypesGen } from \"./types\";\nimport { generateSimpleTask } from \"./SimpleTask\";\nimport { generateDoWhileTask } from \"./DoWhileTask\";\nimport { generateEventTask } from \"./EventTask\";\nimport { generateForkJoinTask, generateJoinTask } from \"./ForkJoin\";\nimport { generateForkJoinDynamic } from \"./ForkJoinDynamicTask\";\nimport { generateHTTPTask } from \"./HttpTask\";\nimport { generateInlineTask } from \"./InlineTask\";\nimport { generateJQTransformTask } from \"./JsonJQTransform\";\nimport { generateKafkaPublishTask } from \"./KafkaTask\";\nimport { generateSubWorkflowTask } from \"./SubWorkflowTask\";\nimport { generateSetVariableTask } from \"./SetVariableTask\";\nimport { generateTerminateTask } from \"./TerminateTask\";\nimport { generateWaitTask } from \"./WaitTask\";\nimport { generateSwitchTask } from \"./SwitchTask\";\nimport { SimpleTaskDef, TaskDefTypes, TaskType } from \"../../common/types\";\n\nconst filledTaskDef = (task: Partial<TaskDefTypesGen>): TaskDefTypes => {\n  const taskType = task.type;\n  switch (taskType) {\n    case TaskType.SWITCH:\n      return generateSwitchTask(task, taskGenMapper);\n    case TaskType.SIMPLE:\n      return generateSimpleTask(task);\n    case TaskType.DO_WHILE:\n      return generateDoWhileTask(task, taskGenMapper);\n    case TaskType.EVENT:\n      return generateEventTask(task);\n    case TaskType.FORK_JOIN:\n      return generateForkJoinTask(task, taskGenMapper);\n    case TaskType.FORK_JOIN_DYNAMIC:\n      return generateForkJoinDynamic(task);\n    case TaskType.HTTP:\n      return generateHTTPTask(task);\n    case TaskType.INLINE:\n      return generateInlineTask(task);\n    case TaskType.JOIN:\n      return generateJoinTask(task);\n    case TaskType.JSON_JQ_TRANSFORM:\n      return generateJQTransformTask(task);\n    case TaskType.KAFKA_PUBLISH:\n      return generateKafkaPublishTask(task);\n    case TaskType.SUB_WORKFLOW:\n      return generateSubWorkflowTask(task);\n    case TaskType.SET_VARIABLE:\n      return generateSetVariableTask(task);\n    case TaskType.TERMINATE:\n      return generateTerminateTask(task);\n    case TaskType.WAIT:\n      return generateWaitTask(task);\n    default:\n      return generateSimpleTask(task as SimpleTaskDef);\n  }\n};\n\nexport const taskGenMapper = (\n  tasks: Partial<TaskDefTypesGen>[]\n): TaskDefTypes[] =>\n  tasks.reduce((acc: TaskDefTypes[], task, idx: number): TaskDefTypes[] => {\n    const filledTask = filledTaskDef(task);\n    const maybeNextTask = tasks.length >= idx + 1 ? tasks[idx + 1] : undefined;\n\n    return acc.concat(maybeAddJoinTask(filledTask, maybeNextTask));\n  }, []);\n\nconst maybeAddJoinTask = (\n  currentTask: TaskDefTypes,\n  maybeNextTask?: Partial<TaskDefTypesGen>\n) => {\n  if (\n    (currentTask.type === TaskType.FORK_JOIN ||\n      currentTask.type === TaskType.FORK_JOIN_DYNAMIC) &&\n    maybeNextTask != null &&\n    maybeNextTask.type !== TaskType.JOIN\n  ) {\n    return [currentTask, generateJoinTask({})];\n  }\n  return currentTask;\n};\n\n/**\n * Takes an optional partial WorkflowDefGen\n * generates a workflow replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @returns a fully defined task\n */\nexport const generate = (overrides: Partial<WorkflowDefGen>) => {\n  const maybeTasks: Partial<TaskDefTypesGen>[] = overrides.tasks || [];\n  const generatedTasks: TaskDefTypes[] = taskGenMapper(maybeTasks);\n  return workflowGenerator({ ...overrides, tasks: generatedTasks });\n};\n","import { generateSimpleTask } from \"./SimpleTask\";\nimport { generateDoWhileTask as doWhileGenerateInner } from \"./DoWhileTask\";\nimport { generateEventTask } from \"./EventTask\";\nimport {\n  generateForkJoinTask as generateForkJoinTaskInner,\n  generateJoinTask,\n} from \"./ForkJoin\";\nimport { generateHTTPTask } from \"./HttpTask\";\nimport { generateInlineTask } from \"./InlineTask\";\nimport { generateJQTransformTask } from \"./JsonJQTransform\";\nimport { generateKafkaPublishTask } from \"./KafkaTask\";\nimport { generateSubWorkflowTask } from \"./SubWorkflowTask\";\nimport { generateSetVariableTask } from \"./SetVariableTask\";\nimport { generateTerminateTask } from \"./TerminateTask\";\nimport { generateWaitTask } from \"./WaitTask\";\nimport { generateSwitchTask as innerGenerateSwitchTask } from \"./SwitchTask\";\n\nimport { taskGenMapper, generate } from \"./generator\";\nimport {\n  SwitchTaskDefGen,\n  NestedTaskMapper,\n  DoWhileTaskDefGen,\n  ForkJoinTaskDefGen,\n} from \"./types\";\n/**\n * Takes an optional partial SwitchTaskDefGen and an optional nestedMapper\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @param nestedTasksMapper function to run on array of nested tasks\n * @returns a fully defined task\n */\nconst generateSwitchTask = (\n  overrides: Partial<SwitchTaskDefGen> = {},\n  nestedTasksMapper: NestedTaskMapper = taskGenMapper\n) => innerGenerateSwitchTask(overrides, nestedTasksMapper);\n\n/**\n * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @param nestedTasksMapper function to run on array of nested tasks\n * @returns a fully defined task\n */\nconst generateDoWhileTask = (\n  overrides: Partial<DoWhileTaskDefGen> = {},\n  nestedTasksMapper: NestedTaskMapper = taskGenMapper\n) => doWhileGenerateInner(overrides, nestedTasksMapper);\n\n/**\n * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper\n * generates a task replacing default/fake values with provided overrides\n *\n * @param overrides overrides for defaults\n * @param nestedTasksMapper function to run on array of nested tasks\n * @returns a fully defined task\n */\nconst generateForkJoinTask = (\n  overrides: Partial<ForkJoinTaskDefGen> = {},\n  nestedMapper: NestedTaskMapper = taskGenMapper\n) => generateForkJoinTaskInner(overrides, nestedMapper);\n\nexport {\n  generateSimpleTask,\n  generateDoWhileTask,\n  generateEventTask,\n  generateForkJoinTask,\n  generateJoinTask,\n  generateHTTPTask,\n  generateInlineTask,\n  generateJQTransformTask,\n  generateKafkaPublishTask,\n  generateSubWorkflowTask,\n  generateSetVariableTask,\n  generateTerminateTask,\n  generateWaitTask,\n  generateSwitchTask,\n  generate,\n  taskGenMapper,\n};\n","import { TaskType, ForkJoinTaskDef, TaskDefTypes, JoinTaskDef } from \"../../common/types\";\nimport { generateJoinTask } from \"../generators\";\n\nexport const forkTask = (\n  taskReferenceName: string,\n  forkTasks: TaskDefTypes[]\n): ForkJoinTaskDef => ({\n  taskReferenceName,\n  name: taskReferenceName,\n  type: TaskType.FORK_JOIN,\n  forkTasks: [forkTasks],\n});\n\nexport const forkTaskJoin = (\n  taskReferenceName: string,\n  forkTasks: TaskDefTypes[]\n): [ForkJoinTaskDef, JoinTaskDef] => [\n  forkTask(taskReferenceName, forkTasks),\n  generateJoinTask({name:`${taskReferenceName}_join`}),\n];\n","import {\n  TaskType,\n  HttpTaskDef,\n  HttpInputParameters,\n} from \"../../common/types\";\n\nexport const httpTask = (\n  taskReferenceName: string,\n  inputParameters: HttpInputParameters\n): HttpTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  inputParameters: {\n    http_request: inputParameters,\n  },\n  type: TaskType.HTTP,\n});\n","import { TaskType, InlineTaskDef } from \"../../common/types\";\n\nexport const inlineTask = (\n  taskReferenceName: string,\n  script: string,\n  evaluatorType: \"javascript\" | \"graaljs\" = \"javascript\"\n): InlineTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  inputParameters: {\n    evaluatorType,\n    expression: script,\n  },\n  type: TaskType.INLINE,\n});\n","import { TaskType, JoinTaskDef } from \"../../common/types\";\n\nexport const joinTask = (\n  taskReferenceName: string,\n  joinOn: string[]\n): JoinTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  joinOn,\n  type: TaskType.JOIN,\n});\n","import { TaskType, JsonJQTransformTaskDef } from \"../../common/types\";\n\nexport const jsonJqTask = (\n  taskReferenceName: string,\n  script: string\n): JsonJQTransformTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  type: TaskType.JSON_JQ_TRANSFORM,\n  inputParameters: {\n    queryExpression: script,\n  },\n});\n","import {\n  TaskType,\n  KafkaPublishTaskDef,\n  KafkaPublishInputParameters,\n} from \"../../common/types\";\n\nexport const kafkaPublishTask = (\n  taskReferenceName: string,\n  kafka_request: KafkaPublishInputParameters\n): KafkaPublishTaskDef => ({\n  taskReferenceName,\n  name: taskReferenceName,\n  type: TaskType.KAFKA_PUBLISH,\n  inputParameters: {\n    kafka_request,\n  },\n});\n","import { TaskType, SetVariableTaskDef } from \"../../common/types\";\n\nexport const setVariableTask = (\n  taskReferenceName: string,\n  inputParameters: Record<string, unknown>\n): SetVariableTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  type: TaskType.SET_VARIABLE,\n  inputParameters,\n});\n","import { TaskType, SimpleTaskDef } from \"../../common/types\";\n\nexport const simpleTask = (\n  taskReferenceName: string,\n  name: string,\n  inputParameters:Record<string,unknown>\n): SimpleTaskDef => ({\n  name,\n  taskReferenceName,\n  inputParameters,\n  type: TaskType.SIMPLE,\n});\n","import { TaskType, SubWorkflowTaskDef } from \"../../common/types\";\n\nexport const subWorkflowTask = (\n  taskReferenceName: string,\n  workflowName: string,\n  version?: number \n): SubWorkflowTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  subWorkflowParam: {\n    name: workflowName,\n    version,\n  },\n  type: TaskType.SUB_WORKFLOW,\n});\n","import { TaskType, SwitchTaskDef, TaskDefTypes } from \"../../common/types\";\n\nexport const switchTask = (\n  taskReferenceName: string,\n  expression: string,\n  decisionCases: Record<string, TaskDefTypes[]> = {},\n  defaultCase: TaskDefTypes[] = []\n): SwitchTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  decisionCases,\n  evaluatorType: \"value-param\",\n  inputParameters: {\n    switchCaseValue: expression,\n  },\n  expression: \"switchCaseValue\",\n  defaultCase,\n  type: TaskType.SWITCH,\n});\n","import type { TaskDef } from '../../common/open-api/models/TaskDef';\n\nexport const taskDefinition = ({\n  name,\n  ownerApp = \"\",\n  description = \"\",\n  retryCount = 3,\n  timeoutSeconds = 3600,\n  inputKeys = [],\n  outputKeys = [],\n  timeoutPolicy = \"TIME_OUT_WF\",\n  retryLogic = \"FIXED\",\n  retryDelaySeconds = 60,\n  responseTimeoutSeconds = 600,\n  concurrentExecLimit = 0,\n  inputTemplate = {},\n  rateLimitPerFrequency = 0,\n  rateLimitFrequencyInSeconds = 1,\n  ownerEmail = \"\",\n  pollTimeoutSeconds = 3600,\n  backoffScaleFactor = 1,\n}: TaskDef) : TaskDef => ({\n  name,\n  ownerApp,\n  description,\n  retryCount,\n  timeoutSeconds,\n  inputKeys,\n  outputKeys,\n  timeoutPolicy,\n  retryLogic,\n  retryDelaySeconds,\n  responseTimeoutSeconds,\n  concurrentExecLimit,\n  inputTemplate,\n  rateLimitPerFrequency,\n  rateLimitFrequencyInSeconds,\n  ownerEmail,\n  pollTimeoutSeconds,\n  backoffScaleFactor,\n})\n","import { TaskType, TerminateTaskDef } from \"../../common/types\";\nexport const terminateTask = (\n  taskReferenceName: string,\n  status: \"COMPLETED\" | \"FAILED\",\n  terminationReason?: string\n): TerminateTaskDef => ({\n  name: taskReferenceName,\n  taskReferenceName,\n  inputParameters: {\n    terminationStatus: status,\n    terminationReason,\n  },\n  type: TaskType.TERMINATE,\n});\n","import { TaskType, WaitTaskDef } from \"../../common/types\";\n\nexport const waitTaskDuration = (taskReferenceName:string,duration:string):WaitTaskDef =>({\n    name:taskReferenceName,\n    taskReferenceName,\n    inputParameters:{\n        duration\n    },\n    type:TaskType.WAIT\n});\n\nexport const waitTaskUntil = (taskReferenceName:string,until:string):WaitTaskDef =>({\n    name:taskReferenceName,\n    taskReferenceName,\n    inputParameters:{\n        until\n    },\n    type:TaskType.WAIT\n})","import { WorkflowDef, TaskDefTypes } from \"../../common/types\";\n\nexport const workflow = (name: string, tasks: TaskDefTypes[]): WorkflowDef => ({\n  name,\n  version: 1,\n  tasks,\n  inputParameters: [],\n  timeoutSeconds: 0,\n});\n","import {\n  ConductorClient,\n  SaveScheduleRequest,\n  SearchResultWorkflowScheduleExecutionModel,\n  WorkflowSchedule,\n} from \"../common\";\nimport { tryCatchReThrow } from \"./helpers\";\n\nexport class SchedulerClient {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n\n  /**\n   * Create or update a schedule for a specified workflow with a corresponding start workflow request\n   * @param requestBody\n   * @returns\n   */\n  public saveSchedule(param: SaveScheduleRequest): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.saveSchedule(param)\n    );\n  }\n\n  /**\n   * Searches for existing scheduler execution based on below parameters\n   *\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflowScheduleExecutionModel\n   */\n  public search(\n    start: number,\n    size: number,\n    sort: string = \"\",\n    freeText: string,\n    query: string\n  ): Promise<SearchResultWorkflowScheduleExecutionModel> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.searchV21(\n        start,\n        size,\n        sort,\n        freeText,\n        query\n      )\n    );\n  }\n\n  /**\n   * Get an existing schedule by name\n   * @param name\n   * @returns SaveScheduleRequest\n   */\n  public getSchedule(name: string): Promise<SaveScheduleRequest> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.getSchedule(name)\n    );\n  }\n\n  /**\n   * Pauses an existing schedule by name\n   * @param name\n   * @returns\n   */\n  public pauseSchedule(name: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.pauseSchedule(name)\n    );\n  }\n\n  /**\n   * Resume a paused schedule by name\n   *\n   * @param name\n   * @returns\n   */\n  public resumeSchedule(name: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.resumeSchedule(name)\n    );\n  }\n\n  /**\n   * Deletes an existing scheduler execution by name\n   *\n   * @param name\n   * @returns\n   */\n  public deleteSchedule(name: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.deleteSchedule(name)\n    );\n  }\n\n  /**\n   * Get all existing workflow schedules and optionally filter by workflow name\n   * @param workflowName\n   * @returns Array<WorkflowSchedule>\n   */\n  public getAllSchedules(\n    workflowName?: string\n  ): Promise<Array<WorkflowSchedule>> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.getAllSchedules(workflowName)\n    );\n  }\n\n  /**\n   * Get list of the next x (default 3, max 5) execution times for a scheduler\n   * @param cronExpression\n   * @param scheduleStartTime\n   * @param scheduleEndTime\n   * @param limit\n   * @returns number OK\n   * @throws ApiError\n   */\n  public getNextFewSchedules(\n    cronExpression: string,\n    scheduleStartTime?: number,\n    scheduleEndTime?: number,\n    limit: number = 3\n  ): Promise<Array<number[]>> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.getNextFewSchedules(\n        cronExpression,\n        scheduleStartTime,\n        scheduleEndTime,\n        limit\n      )\n    );\n  }\n\n  /**\n   * Pause all scheduling in a single conductor server instance (for debugging only)\n   * @returns any OK\n   * @throws ApiError\n   */\n  public pauseAllSchedules(): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.pauseAllSchedules()\n    );\n  }\n\n  /**\n   * Requeue all execution records\n   * @returns any OK\n   * @throws ApiError\n   */\n  public requeueAllExecutionRecords(): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.requeueAllExecutionRecords()\n    );\n  }\n\n  /**\n   * Resume all scheduling\n   * @returns any OK\n   * @throws ApiError\n   */\n  public resumeAllSchedules(): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.schedulerResource.resumeAllSchedules()\n    );\n  }\n}\n","import { TaskResultStatus } from \"../core/types\";\nimport {\n  ConductorClient,\n  SearchResultTask,\n  Task,\n  TaskResult,\n} from \"../common\";\nimport { tryCatchReThrow } from \"./helpers\";\n\nexport class TaskClient {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n\n  /**\n   * Searches for existing scheduler execution based on below parameters\n   *\n   * @param start\n   * @param size\n   * @param sort\n   * @param freeText\n   * @param query\n   * @returns SearchResultWorkflowScheduleExecutionModel\n   */\n  public search(\n    start: number,\n    size: number,\n    sort: string = \"\",\n    freeText: string,\n    query: string\n  ): Promise<SearchResultTask> {\n    return tryCatchReThrow(() =>\n      this._client.taskResource.search(\n        start,\n        size,\n        sort,\n        freeText,\n        query\n      )\n    );\n  }\n\n  /**\n   * Get an existing schedule by Id\n   * @param taskId\n   * @returns Task\n   */\n  public getTask(taskId: string): Promise<Task> {\n    return tryCatchReThrow(() =>\n      this._client.taskResource.getTask(taskId)\n    );\n  }\n\n  /**\n   * Update task result status\n   *\n   * @param workflowId\n   * @param taskReferenceName\n   * @param status\n   * @param outputData\n   * @param workerId\n   * @returns\n   */\n  public updateTaskResult(\n    workflowId: string,\n    taskReferenceName: string,\n    status: TaskResultStatus,\n    outputData: Record<string, unknown>,\n  ): Promise<TaskResult> {\n    return tryCatchReThrow(() =>\n      this._client.taskResource.updateTask(\n        workflowId,\n        taskReferenceName,\n        status,\n        outputData\n      )\n    );\n  }\n}\n","import {\n  ConductorClient,\n  HumanTaskTemplate,\n} from \"../common\";\nimport { tryCatchReThrow } from \"./helpers\";\n\n\nexport class TemplateClient {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n\n  /**\n   * Register a new human task template\n   *\n   * @param template\n   * @returns\n   */\n  public async registerTemplate(\n    template: HumanTaskTemplate,\n    asNewVersion: boolean = false\n  ): Promise<HumanTaskTemplate> {\n    return tryCatchReThrow(() =>\n      this._client.humanTask.saveTemplate(template, asNewVersion)\n    );\n  }\n}\n","import { ConductorClient, TaskDef } from \"../common\";\nimport { WorkflowDef } from \"../common/open-api\";\nimport { tryCatchReThrow } from \"./helpers\";\n\nexport class MetadataClient {\n  public readonly _client: ConductorClient;\n\n  constructor(client: ConductorClient) {\n    this._client = client;\n  }\n\n  /**\n   * Unregisters an existing task definition by name\n   *\n   * @param name\n   * @returns\n   */\n  public unregisterTask(name: string): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.metadataResource.unregisterTaskDef(name)\n    );\n  }\n\n  /**\n   * Registers a new task definition\n   *\n   * @param taskDef\n   * @returns\n   */\n  public registerTask(taskDef: TaskDef): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.metadataResource.registerTaskDef([taskDef])\n    );\n  }\n\n  /**\n   * Update an existing task definition\n   *\n   * @param taskDef\n   * @returns\n   */\n  public updateTask(taskDef: TaskDef): Promise<void> {\n    return tryCatchReThrow(() =>\n      this._client.metadataResource.updateTaskDef(taskDef)\n    );\n  }\n\n  /**\n   * Creates or updates (overwrite: true) a workflow definition\n   *\n   * @param workflowDef\n   * @param overwrite\n   * @returns\n   */\n  public registerWorkflowDef(\n    workflowDef: WorkflowDef,\n    overwrite: boolean = false\n  ) {\n    return tryCatchReThrow(() =>\n      this._client.metadataResource.create(workflowDef, overwrite)\n    );\n  }\n}\n","import type { ConductorHttpRequest, ConductorClientAPIConfig } from \"../common\";\nimport { ConductorClient } from \"../common\";\nimport { FetchFn, OrkesApiConfig } from \"./types\";\n\nconst defaultRequestHandler: ConductorHttpRequest = (\n  request,\n  config,\n  options\n) => request(config, options);\n\nconst REFRESH_TOKEN_IN_MILLISECONDS = 30 * 60 * 1000;\n\nexport class AuthConductorClient extends ConductorClient {\n  public intervalId?: NodeJS.Timeout;\n  constructor(\n    config?: Partial<ConductorClientAPIConfig>,\n    requestHandler: ConductorHttpRequest = defaultRequestHandler\n  ) {\n    super(config, requestHandler);\n  }\n  /**\n   * Stops the interval that refreshes the token\n   */\n  stop(): void {\n    if (this.intervalId != null) {\n      clearInterval(this.intervalId);\n    }\n  }\n}\n/*\nReturns an orkes conductor client creator function.\nUsefull if you want to use your own fetch. like Got or Axios\n */\nexport const baseOrkesConductorClient = <\n  T = RequestInit,\n  R extends { json: () => Promise<any> } = Response\n>(\n  fetchFn: FetchFn<T, R>,\n  baseRequestHandler: ConductorHttpRequest = defaultRequestHandler\n) => {\n  const requestTokenForKeySecret = (\n    keyId: string,\n    keySecret: string,\n    tokenUrl: string\n  ) =>\n    fetchFn(tokenUrl, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n      },\n      body: JSON.stringify({ keyId, keySecret }),\n      method: \"POST\",\n    } as any);\n\n  return async (\n    config?: Partial<OrkesApiConfig>,\n    requestHandler: ConductorHttpRequest = baseRequestHandler\n  ): Promise<ConductorClient> => {\n    if (config?.useEnvVars) {\n      if (!process.env.CONDUCTOR_SERVER_URL) {\n        throw new Error(\n          \"Environment variable CONDUCTOR_SERVER_URL is not defined.\"\n        );\n      }\n\n      config.serverUrl = process.env.CONDUCTOR_SERVER_URL;\n      config.keyId = process.env.CONDUCTOR_AUTH_KEY;\n      config.keySecret = process.env.CONDUCTOR_AUTH_SECRET;\n    }\n\n    if (config?.keySecret != null && config?.keyId != null) {\n      const {\n        serverUrl,\n        keyId,\n        keySecret,\n        refreshTokenInterval = REFRESH_TOKEN_IN_MILLISECONDS,\n      } = config;\n      const tokenUrl = `${serverUrl}/token`;\n      const res = await requestTokenForKeySecret(keyId, keySecret, tokenUrl);\n      const { token } = await (res as R).json();\n\n      const conductorClientInstance = new AuthConductorClient(\n        { ...config, TOKEN: token },\n        requestHandler\n      );\n\n      if (token != null && refreshTokenInterval > 0) {\n        const intervalId = setInterval(async () => {\n          const res = await requestTokenForKeySecret(\n            keyId,\n            keySecret,\n            tokenUrl\n          );\n          const { token } = await res.json();\n          conductorClientInstance.token = token;\n        }, refreshTokenInterval);\n        conductorClientInstance.intervalId = intervalId;\n      }\n\n      return conductorClientInstance;\n    } else {\n      return new ConductorClient(config, requestHandler);\n    }\n  };\n};\n","import type { ConductorHttpRequest } from \"../common\";\nimport { baseOrkesConductorClient } from \"./BaseOrkesConductorClient\";\n\nconst defaultRequestHandler: ConductorHttpRequest = (\n  request,\n  config,\n  options\n) => request(config, options);\n/**\n * Takes a config with keyId and keySecret returns a promise with an instance of ConductorClient\n *\n * @param config ConductorClientConfig with keyId and keySecret\n * @param requestHandler (optional) ConductorHttpRequest handler\n * @returns\n */\nexport const orkesConductorClient = baseOrkesConductorClient(\n  fetch,\n  defaultRequestHandler\n);\n","/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\nimport type {\n  OnCancel,\n  OpenAPIConfig,\n  ApiResult,\n  ApiRequestOptions,\n} from \"../../common\";\nimport { CancelablePromise, ApiError } from \"../../common\";\nimport type { FetchFn } from \"../types\";\n\nconst isDefined = <T>(\n  value: T | null | undefined\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\nconst isString = (value: any): value is string => {\n  return typeof value === \"string\";\n};\n\nconst isStringWithValue = (value: any): value is string => {\n  return isString(value) && value !== \"\";\n};\n\nconst isBlob = (value: any): value is Blob => {\n  return (\n    typeof value === \"object\" &&\n    typeof value.type === \"string\" &&\n    typeof value.stream === \"function\" &&\n    typeof value.arrayBuffer === \"function\" &&\n    typeof value.constructor === \"function\" &&\n    typeof value.constructor.name === \"string\" &&\n    /^(Blob|File)$/.test(value.constructor.name) &&\n    /^(Blob|File)$/.test(value[Symbol.toStringTag])\n  );\n};\n\nconst isFormData = (value: any): value is FormData => {\n  return value instanceof FormData;\n};\n\nconst base64 = (str: string): string => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString(\"base64\");\n  }\n};\n\nconst getQueryString = (params: Record<string, any>): string => {\n  const qs: string[] = [];\n\n  const append = (key: string, value: any) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  const process = (key: string, value: any) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => {\n          process(key, v);\n        });\n      } else if (typeof value === \"object\") {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join(\"&\")}`;\n  }\n\n  return \"\";\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n\n  const path = options.url\n    .replace(\"{api-version}\", config.VERSION)\n    .replace(/{(.*?)}/g, (substring: string, group: string) => {\n      if (options.path?.hasOwnProperty(group)) {\n        return encoder(String(options.path[group]));\n      }\n      return substring;\n    });\n\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\n\nconst getFormData = (options: ApiRequestOptions): FormData | undefined => {\n  if (options.formData) {\n    const formData = new FormData();\n\n    const process = (key: string, value: any) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData)\n      .filter(([_, value]) => isDefined(value))\n      .forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((v) => process(key, v));\n        } else {\n          process(key, value);\n        }\n      });\n\n    return formData;\n  }\n  return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nconst resolve = async <T>(\n  options: ApiRequestOptions,\n  resolver?: T | Resolver<T>\n): Promise<T | undefined> => {\n  if (typeof resolver === \"function\") {\n    return (resolver as Resolver<T>)(options);\n  }\n  return resolver;\n};\n\nconst getHeaders = async (\n  config: OpenAPIConfig,\n  options: ApiRequestOptions\n): Promise<Headers> => {\n  const token = await resolve(options, config.TOKEN);\n  const username = await resolve(options, config.USERNAME);\n  const password = await resolve(options, config.PASSWORD);\n  const additionalHeaders = await resolve(options, config.HEADERS);\n\n  const headers = Object.entries({\n    Accept: \"application/json\",\n    ...additionalHeaders,\n    ...options.headers,\n  })\n    .filter(([_, value]) => isDefined(value))\n    .reduce(\n      (headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n      }),\n      {} as Record<string, string>\n    );\n\n  if (isStringWithValue(token)) {\n    headers[\"X-AUTHORIZATION\"] = token;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers[\"Authorization\"] = `Basic ${credentials}`;\n  }\n\n  if (options.body) {\n    if (options.mediaType) {\n      headers[\"Content-Type\"] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers[\"Content-Type\"] = \"application/octet-stream\";\n    } else if (isString(options.body)) {\n      headers[\"Content-Type\"] = \"text/plain\";\n    } else if (!isFormData(options.body)) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n  }\n\n  return new Headers(headers);\n};\n\nconst getRequestBody = (options: ApiRequestOptions): any => {\n  if (options.body) {\n    if (options.mediaType?.includes(\"/json\")) {\n      return JSON.stringify(options.body);\n    } else if (\n      isString(options.body) ||\n      isBlob(options.body) ||\n      isFormData(options.body)\n    ) {\n      return options.body as any;\n    } else {\n      return JSON.stringify(options.body);\n    }\n  }\n  return undefined;\n};\n\nconst sendRequest = async (\n  options: ApiRequestOptions,\n  url: string,\n  body: any,\n  formData: FormData | undefined,\n  headers: Headers,\n  onCancel: OnCancel,\n  fetchFn: FetchFn<RequestInit, Response> = fetch\n): Promise<Response> => {\n  const controller = new AbortController();\n\n  const request: RequestInit = {\n    headers,\n    method: options.method,\n    body: body ?? formData,\n    signal: controller.signal as AbortSignal,\n  };\n\n  onCancel(() => controller.abort());\n\n  return await fetchFn(url, request);\n};\n\nconst getResponseHeader = (\n  response: Response,\n  responseHeader?: string\n): string | undefined => {\n  if (responseHeader) {\n    const content = response.headers.get(responseHeader);\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return undefined;\n};\n\nconst getResponseBody = async (response: Response): Promise<any> => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get(\"Content-Type\");\n      if (contentType) {\n        const isJSON = contentType.toLowerCase().startsWith(\"application/json\");\n        if (isJSON) {\n          return await response.json();\n        } else {\n          return await response.text();\n        }\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return undefined;\n};\n\nconst catchErrorCodes = (\n  options: ApiRequestOptions,\n  result: ApiResult\n): void => {\n  const errors: Record<number, string> = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    500: \"Internal Server Error\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    ...options.errors,\n  };\n\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n\n  if (!result.ok) {\n    throw new ApiError(options, result, \"Generic Error\");\n  }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  fetchFn: FetchFn = fetch\n): CancelablePromise<T> => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    try {\n      const url = getUrl(config, options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options);\n\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(\n          options,\n          url,\n          body,\n          formData,\n          headers,\n          onCancel,\n          fetchFn\n        );\n        const responseBody = await getResponseBody(response);\n        const responseHeader = getResponseHeader(\n          response,\n          options.responseHeader\n        );\n\n        const result: ApiResult = {\n          url,\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader ?? responseBody,\n        };\n\n        catchErrorCodes(options, result);\n\n        resolve(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n"],"mappings":"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","names":["generateDoWhileTask","generateForkJoinTask","generateSwitchTask","request","TaskType","request","resolve","process","headers","request","resolve","request","os","workflow","DEFAULT_POLL_INTERVAL","resolve","generateSwitchTask","generateDoWhileTask","generateForkJoinTask","defaultRequestHandler","request","res","token","defaultRequestHandler","request","isDefined","isString","isStringWithValue","isBlob","isFormData","base64","getQueryString","process","getUrl","getFormData","resolve","getHeaders","headers","getRequestBody","sendRequest","request","getResponseHeader","getResponseBody","catchErrorCodes"]}